<?xml version="1.0"?>
<!--
    ***** BEGIN LICENSE BLOCK *****
    
    Copyright Â© 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org
    
    This file is part of Zotero.
    
    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
    
    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.
    
    ***** END LICENSE BLOCK *****
-->

<!DOCTYPE bindings SYSTEM "chrome://zotero/locale/zotero.dtd">
<!-- <!DOCTYPE bindings SYSTEM "chrome://zotero/locale/itembox.dtd"> -->

<!--
  ============================
  Multilingual processing flow
  ============================

  Ordinary fields

  Ordinary fields are added by invoking "openMultiFieldRow()".
  If the object already exists, it is opened for editing.
  Otherwise, a multilingual variant of the field is created on
  the memory item, followed by a "refresh()" operation
  (triggered by "item.save()").  The "refresh()"
  generates the XUL field object automatically, without
  direct manipulation of the DOM in "openMultiFieldRow()".

  Ordinary fields are deleted by saving them with no
  content.  When the "item.save()" operation is performed,
  the field is deleted from the database and from the
  memory object, before the "refresh()" step.

  Creator fields

  Top-level (non-variant) creator fields are added by
  invoking the "addCreatorRow()" method.  This creates
  a new representation of an item in the DOM and opens
  it for editing.  The data is saved when the edit is
  closed; if the entry is empty or contains only the
  default name form, the item is not saved, and disappears
  with the final "refresh()" operation.
  
  Creator field variants are added by invoking the 
  "openMultiCreatorRow()" method.  If the item
  already exists, it is opened for editing.  Otherwise,
  an item carrying the same content as the headline
  entry is appended after the last entry for the
  creator, using the same processing flow as for
  "openMultiFieldRow()".

  Child entries can be deleted only explictly by
  using the "(-)" button.  An attempt to save
  with empty content will have no effect. 

  A helper function "buildCreatorRow()" is used
  by "refresh()", "addCreatorRow()", and
  "openMultiCreatorRow()" to build the DOM
  representation of an entry.
  
-->


<bindings xmlns="http://www.mozilla.org/xbl"
		  xmlns:xbl="http://www.mozilla.org/xbl"
		  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
	
	<binding id="item-box">
		<resources>
			<stylesheet src="chrome://zotero/skin/bindings/itembox.css"/>
			<stylesheet src="chrome://zotero-platform/content/itembox.css"/>
		</resources>
		
		<implementation>
			<!--
				Public properties
			-->
			<field name="clickable">false</field>
			<field name="editable">false</field>
			<field name="saveOnEdit">false</field>
			<field name="showTypeMenu">false</field>
			<field name="hideEmptyFields">false</field>
			<field name="clickByRow">false</field> <!-- Click entire row rather than just field value -->
			<field name="clickByItem">false</field>
			
			<field name="clickHandler"/>
			<field name="blurHandler"/>
			<field name="eventHandlers">[]</field>
			
			<field name="_initialVisibleCreators">10</field>
			<field name="_displayAllCreators"/>
			
			<!-- Modes are predefined settings groups for particular tasks -->
			<field name="_mode">"view"</field>
			<property name="mode" onget="return this._mode;">
				<setter>
				<![CDATA[
					this.clickable = false;
					this.editable = false;
					this.saveOnEdit = false;
					this.showTypeMenu = false;
					this.hideEmptyFields = false;
					this.clickByRow = false;
					this.clickByItem = false;
					if (!this.utilities) {
						this.utilities = Zotero.Utilities;
					}
					switch (val) {
						case 'view':
							break;
						
						case 'edit':
							this.clickable = true;
							this.editable = true;
							this.saveOnEdit = true
							this.showTypeMenu = true;
							this.clickHandler = this.showEditor;
							this.blurHandler = this.hideEditor;
							break;
						
						case 'merge':
							this.clickByItem = true;
							break;
						
						case 'mergeedit':
							this.clickable = true;
							this.editable = true;
							this.saveOnEdit = false;
							this.showTypeMenu = true;
							this.clickHandler = this.showEditor;
							this.blurHandler = this.hideEditor;
							break;
						
						case 'fieldmerge':
							this.hideEmptyFields = true;
							this._fieldAlternatives = {};
							break;
						
						default:
							throw ("Invalid mode '" + val + "' in itembox.xml");
					}
					
					this._mode = val;
					document.getAnonymousNodes(this)[0].setAttribute('mode', val);
				]]>
				</setter>
			</property>
			
			<field name="_item"/>
			<property name="item" onget="return this._item;">
				<setter>
				<![CDATA[
					if (!(val instanceof Zotero.Item)) {
						throw ("<zoteroitembox>.item must be a Zotero.Item");
					}
					
					// When changing items, reset truncation of creator list
					if (!this._item || val.id != this._item.id) {
						this._displayAllCreators = false;
					}
					
					this._item = val;
					this.refresh();
				]]>
				</setter>
			</property>
			
			<!-- .ref is an alias for .item -->
			<property name="ref"
				onget="return this._item;"
				onset="this.item = val; this.refresh();">
			</property>

			<field name="_leftClick">false</field>
			
			<!--
				 An array of field names that should be shown
				 even if they're empty and hideEmptyFields is set
			-->
			<field name="_visibleFields">[]</field>
			<property name="visibleFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('visibleFields must be an array in <itembox>.visibleFields');
					}
					
					this._visibleFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be hidden
			-->
			<field name="_hiddenFields">[]</field>
			<property name="hiddenFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('hiddenFields must be an array in <itembox>.visibleFields');
					}
					
					this._hiddenFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be clickable
				 even if this.clickable is false
			-->
			<field name="_clickableFields">[]</field>
			<property name="clickableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('clickableFields must be an array in <itembox>.clickableFields');
					}
					
					this._clickableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names that should be editable
				 even if this.editable is false
			-->
			<field name="_editableFields">[]</field>
			<property name="editableFields">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('editableFields must be an array in <itembox>.editableFields');
					}
					
					this._editableFields = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An object of alternative values for keyed fields
				 
			-->
			<field name="_fieldAlternatives">{}</field>
			<property name="fieldAlternatives">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Object') {
						throw ('fieldAlternatives must be an Object in <itembox>.fieldAlternatives');
					}
					
					if (this.mode != 'fieldmerge') {
						throw ('fieldAlternatives is valid only in fieldmerge mode in <itembox>.fieldAlternatives');
					}
					
					this._fieldAlternatives = val;
				]]>
				</setter>
			</property>
			
			<!--
				 An array of field names in the order they should appear
				 in the list; empty spaces can be created with null
			-->
			<field name="_fieldOrder">[]</field>
			<property name="fieldOrder">
				<setter>
				<![CDATA[
					if (val.constructor.name != 'Array') {
						throw ('fieldOrder must be an array in <itembox>.fieldOrder');
					}
					
					this._fieldOrder = val;
				]]>
				</setter>
			</property>
			
			<property name="itemTypeMenu" onget="return this._id('item-type-menu')"/>
			
			<!-- Private properties -->
			<property name="_dynamicFields" onget="return this._id('dynamic-fields')"/>
			<property name="_creatorTypeMenu" onget="return this._id('creator-type-menu')"/>
			<property name="_multiSpawnPopup" onget="return this._id('multi-spawn-popup')"/>
			<property name="_multiSpawnMenu" onget="return this._id('multi-spawn-menu')"/>
			<property name="_multiLangSep" onget="return this._id('zotero-creator-lang-sep')"/>
			<property name="_multiMoveSep" onget="return this._id('zotero-creator-move-sep')"/>

			<field name="_selectField"/>
			<field name="_beforeRow"/>
			<field name="_addCreatorRow"/>
			<field name="_creatorCount"/>
			<field name="_creatorTabCount"/>
			
			<field name="_lastTabIndex"/>
			<field name="_tabDirection"/>
			<field name="_tabIndexMinCreators" readonly="true">10</field>
			<field name="_tabIndexMaxCreators">0</field>
			<field name="_tabIndexMinFields" readonly="true">1000</field>
			<field name="_tabIndexMaxInfoFields">0</field>
			<field name="_tabIndexMaxTagsFields">0</field>
			
			<property name="_defaultFirstName"
				onget="return '(' + Zotero.getString('pane.item.defaultFirstName') + ')'"/>
			<property name="_defaultLastName"
				onget="return '(' + Zotero.getString('pane.item.defaultLastName') + ')'"/>
			<property name="_defaultFullName"
				onget="return '(' + Zotero.getString('pane.item.defaultFullName') + ')'"/>
			

			<method name="refreshLanguages">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var i, ilen;
					// Build standard language menu
					var menu = this._multiSpawnMenu;
					if (Zotero.CachedLanguages.menuHasChanged()) {
						// Remove all nodes
						for (i = menu.childNodes.length - 1; i > -1; i += -1) {
							menu.removeChild(menu.childNodes[i]);
						}
						// Rebuild
						var languageList = Zotero.Utilities.languageList();
						for (i = 0, ilen = languageList.length; i < ilen; i += 1) {
							var nickname = languageList[i].nickname;
							var tag = languageList[i].tag
							var fnode = document.createElement('menuitem');
							fnode.setAttribute('label',nickname);
							fnode.setAttribute('value',tag);
							fnode.setAttribute('onclick', "document.getBindingParent(this).openMultiRow('"+tag+"');");
							menu.appendChild(fnode);
						}
					}
					if (!menu.childNodes.length) {
						return false;
					}
					// Hide languages that are already used.
					var row = Zotero.getAncestorByTagName(node, 'row');
					var fieldstring = row.firstChild.getAttribute('fieldname');
					var fieldname = fieldstring.split('-')[0];
					var multi = this.item.multi;
					if (fieldname && "creator" === fieldname.slice(0, 7)) {
						var pos = fieldstring.split('-')[1];
						var creator = this.item.getCreator(pos);
						multi = creator.multi;
					}
					for (var i = 0, ilen = menu.childNodes.length; i < ilen; i += 1) {
						if (multi && multi.hasLang(menu.childNodes[i].getAttribute('value'),fieldname)) {
							menu.childNodes[i].setAttribute('disabled', true);
							menu.childNodes[i].setAttribute('onclick', "return false");
						}
					}
					return true;
				]]>
				</body>
			</method>

			<method name="stackTrace">
				<body>
				<![CDATA[
					// For debugging: I needed a stack trace to explore an
					// issue with the notifier clobbering the UI, and couldn't
					// get Firebug to work for that purpose.
					//
					// Based on code from Eric Wendelin at:
					//   http://eriwen.com/javascript/js-stack-trace/
					//
					// Set the comparison value of _hasTraced to the iteration
					// count at which the trace should be triggered. The function
					// will run only once per Firefox session.
					//
					if (!this._hasTraced) {
  						this._hasTraced = 1;
					}
					if (this._hasTraced === 3) {
 						var callstack = [];
 						var isCallstackPopulated = false;
						try {
 							i.dont.exist+=0; //doesn't exist- that's the point
						} catch(e) {
							if (e.stack) {
								var lines = e.stack.split('\n');
								for (var i=0, ilen=lines.length; i < ilen; i++) {
									if (lines[i].match(/^\s*[A-Za-z0-9\-_\$]+\(/)) {
										callstack.push(lines[i]);
									}
								}
								//Remove call to printStackTrace()
								callstack.shift();
								isCallstackPopulated = true;
							}
						}
						alert(callstack.join('\n\n'));
					}
					this._hasTraced += 1;
				]]>
				</body>
			</method>
			<method name="refresh">
				<body>
				<![CDATA[
					//Zotero.debug("XXX === refresh() === [start]");

					// For example. 
					//this.stackTrace();

					this.itemLanguage = this.item.getField("language");

					var i, ilen;

					if (!this.item) {
						Zotero.debug('No item to refresh', 2);
						return;
					}
					
					var languageList = Zotero.Utilities.languageList(this._item);

					if (this.clickByItem) {
						var itemBox = document.getAnonymousNodes(this)[0];
						itemBox.setAttribute('onclick',
							'document.getBindingParent(this).clickHandler(this)');
					}

					// Item type menu
					if (this.showTypeMenu) {
						// Build item type menu if it hasn't been built yet
						if (this.itemTypeMenu.itemCount == 0) {
							this.buildItemTypeMenu();
						}
						else {
							this.updateItemTypeMenuSelection();
						}
						this.itemTypeMenu.parentNode.hidden = false;
					}
					else {
						this.itemTypeMenu.parentNode.hidden = true;
					}
					
					
					//
					// Clear and rebuild metadata fields
					//
					while (this._dynamicFields.childNodes.length > 1) {
						this._dynamicFields.removeChild(this._dynamicFields.lastChild);
					}

					var fieldNames = [];
					
					// Manual field order
					if (this._fieldOrder.length) {
						for each(var field in this._fieldOrder) {
							fieldNames.push(field);
						}
					}
					// Get field order from database
					else {
						if (!this.showTypeMenu) {
							fieldNames.push("itemType");
						}
						
						var fields = Zotero.ItemFields.getItemTypeFields(this.item.getField("itemTypeID"));
						
						for (var i=0; i<fields.length; i++) {
							fieldNames.push(Zotero.ItemFields.getName(fields[i]));
						}
						
						fieldNames.push("dateAdded", "dateModified");
					}
					
					for (var i=0; i<fieldNames.length; i++) {
						var fieldName = fieldNames[i];
						var val = '';
						
						if (fieldName) {
							var fieldID = Zotero.ItemFields.getID(fieldName);
							if (fieldID && !Zotero.ItemFields.isValidForType(fieldID, this.item.itemTypeID)) {
								fieldName = null;
							}
						}
						
						if (fieldName) {
							if (this._hiddenFields.indexOf(fieldName) != -1) {
								continue;
							}
							
							// createValueElement() adds the itemTypeID as an attribute
							// and converts it to a localized string for display
							if (fieldName == 'itemType') {
								val = this.item.getField('itemTypeID');
							}
							else {
								val = this.item.getField(fieldName);
							}
							
							if (!val && this.hideEmptyFields
									&& this._visibleFields.indexOf(fieldName) == -1
									&& (this.mode != 'fieldmerge' || typeof this._fieldAlternatives[fieldName] == 'undefined')) {
								continue;
							}
							
							var fieldIsClickable = this._fieldIsClickable(fieldName);
							
							// Start tabindex at 1001 after creators
							var tabindex = fieldIsClickable
								? (i>0 ? this._tabIndexMinFields + i : 1) : 0;
							this._tabIndexMaxInfoFields = Math.max(this._tabIndexMaxInfoFields, tabindex);
							
							if (fieldIsClickable
									&& !Zotero.Items.isPrimaryField(fieldName)
									&& (Zotero.ItemFields.isFieldOfBase(Zotero.ItemFields.getID(fieldName), 'date')
										// TEMP - filingDate
										|| ['filingDate','priorityDate','publicationDate','originalDate','signingDate','openingDate','adoptionDate','newsCaseDate','conferenceDate'].indexOf(fieldName) > -1)
									// TEMP - NSF
									&& fieldName != 'dateSent') {
								this.addDateRow(fieldNames[i], this.item.getField(fieldName, true), tabindex);
								continue;
							}
						}
						
						var valueElement = this.createValueElement(
							val, fieldName, tabindex
						);
						
						var label = document.createElement("label");
						label.setAttribute('fieldname', fieldName);
						if (languageList.length) {
							if (Zotero.multiFieldNames[fieldName]) {
								this.addMultiListener(label);
								if (this.editable) {
									label.setAttribute('popup', 'multi-spawn-popup');
									label.setAttribute('contextmenu', 'multi-spawn-popup');
									label.setAttribute('class', 'zotero-alien-clicky');
								}
							}
						}

						var prefix = '';
						// Add '(...)' before 'Abstract:' for collapsed abstracts
						if (fieldName == 'abstractNote') {
							if (val && !Zotero.Prefs.get('lastAbstractExpand')) {
								prefix = '(...) ';
							}
						}
						
						if (fieldName) {
							label.setAttribute("value", prefix +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldName) + ":");
						}
						
						// TEMP - NSF (homepage)
						if ((fieldName == 'url' || fieldName == 'homepage') && val) {
							label.setAttribute("isButton", true);
							// TODO: make getFieldValue non-private and use below instead
							label.setAttribute("onclick", "ZoteroPane_Local.loadURI(this.nextSibling.firstChild ? this.nextSibling.firstChild.nodeValue : this.nextSibling.value, event)");
							label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
						}
						else if (fieldName == 'DOI' && val && typeof val == 'string') {
							// Pull out DOI, in case there's a prefix
							var doi = Zotero.Utilities.cleanDOI(val);
							if (doi) {
								doi = "http://dx.doi.org/" + encodeURIComponent(doi);
								label.setAttribute("isButton", true);
								label.setAttribute("onclick", "ZoteroPane_Local.loadURI('" + doi + "', event)");
								label.setAttribute("tooltiptext", Zotero.getString('locate.online.tooltip'));
							}
						}
						else if (fieldName == 'abstractNote') {
							label.setAttribute("onclick",
								"if (this.nextSibling.inputField) { this.nextSibling.inputField.blur(); } "
								+ "else { document.getBindingParent(this).toggleAbstractExpand(this); }");
						}
						else {
							label.setAttribute("onclick",
								"if (this.nextSibling.inputField) { this.nextSibling.inputField.blur(); }");
						}
						var row = this.addDynamicRow(label, valueElement);

						if (fieldName && this._selectField == fieldName) {
							this.showEditor(valueElement);
						}

						// In field merge mode, add a button to switch field versions
						else if (this.mode == 'fieldmerge' && typeof this._fieldAlternatives[fieldName] != 'undefined') {
							var button = document.createElement("toolbarbutton");
							button.className = 'zotero-field-version-button';
							button.setAttribute('image', 'chrome://zotero/skin/treesource-duplicates.png');
							button.setAttribute('type', 'menu');
							
							var popup = button.appendChild(document.createElement("menupopup"));
							
							for each(var v in this._fieldAlternatives[fieldName]) {
								var menuitem = document.createElement("menuitem");
								var sv = Zotero.Utilities.ellipsize(v, 60);
								menuitem.setAttribute('label', sv);
								if (v != sv) {
									menuitem.setAttribute('tooltiptext', v);
								}
								menuitem.setAttribute('fieldName', fieldName);
								menuitem.setAttribute('originalValue', v);
								menuitem.setAttribute(
									'oncommand',
									"var binding = document.getBindingParent(this); "
									+ "var item = binding.item; "
									+ "item.setField(this.getAttribute('fieldName'), this.getAttribute('originalValue')); "
									+ "var row = Zotero.getAncestorByTagName(this, 'row'); "
									+ "binding.refresh();"
								);
								popup.appendChild(menuitem);
							}
							
							row.appendChild(button);
						}

						if (Zotero.multiFieldNames[fieldName]) {
							var fieldID = Zotero.ItemFields.getID(fieldName);

							for (var langTag in this.item.multi._keys[fieldID]) {
								Zotero.CachedLanguages.getNickname(langTag);
							}

							var mainLang = this.item.multi.main[fieldID];

							if (mainLang) {
								var nickname = Zotero.CachedLanguages.getNickname(mainLang);
								label.parentNode.setAttribute('tooltiptext', nickname);
							}

							Zotero.setRTL(row.firstChild.nextSibling, [this.itemLanguage, mainLang]);

							// OOOOO: Could use a more efficient method for this
							for (var j = 0, jlen = languageList.length; j < jlen; j += 1) {
								if (!this.item.multi.get(fieldID, languageList[j].tag, true)
									|| languageList[j].tag === mainLang) {
										continue;
								}
								// (key is a languageTag)
								key = languageList[j].tag;
								var fieldNamePlusLang = fieldName + "-" + key
								var label = document.createElement('label');
								var nickname = Zotero.CachedLanguages.getNickname(key);
								if (!nickname) {
									Zotero.debug("Invalid language tag: "+key);
									continue;
								}
								if (this.editable) {
									this.addMultiListener(label);
									label.setAttribute('popup', 'multi-spawn-popup');
								}
								label.setAttribute('value', nickname);
								label.className = 'zotero-langy';
								label.setAttribute('fieldname', fieldNamePlusLang);
								label.setAttribute('servantLang', key);
								if (this.editable) {
									if (this._clickableFields.indexOf(fieldNamePlusLang) === -1) {
										this._clickableFields.push(fieldNamePlusLang);
									}
								}
								var valueElement = this.createValueElement(
									this.item.multi.get(fieldID, key), 
									fieldNamePlusLang, 
									tabindex
								);
								var row = this.addDynamicRow(label, valueElement);

								Zotero.setRTL(row.firstChild.nextSibling, [this.itemLanguage, key]);
							}
						} else {
							Zotero.setRTL(row.firstChild.nextSibling, [this.itemLanguage]);
						}
					}
					this._selectField = false;
					
					//
					// Creators
					//

					// Creator type menu
					if (this.editable) {
						var next = this._creatorTypeMenu.firstChild;
						while ('zotero-creator-move-sep' !== next.getAttribute('id')) {
							this._creatorTypeMenu.removeChild(next);
							next = this._creatorTypeMenu.firstChild;
						}

						var creatorTypes = Zotero.CreatorTypes.getTypesForItemType(this.item.itemTypeID);

						var localized = {};
						for (var i=0; i<creatorTypes.length; i++) {
							localized[creatorTypes[i]['name']]
								= Zotero.getString('creatorTypes.' + creatorTypes[i]['name']);
						}
						
						var moveSep = this._creatorTypeMenu.firstChild;
						for (var i in localized) {
							var menuitem = document.createElement("menuitem");
							menuitem.setAttribute("label", localized[i]);
							menuitem.setAttribute("typeid", Zotero.CreatorTypes.getID(i));
							this._creatorTypeMenu.insertBefore(menuitem, moveSep);
						}
					}

					// Creator rows
					// Place, in order of preference, after title, after type,
					// or at beginning
					var titleFieldID = Zotero.ItemFields.getFieldIDFromTypeAndBase(this.item.itemTypeID, 'title');
					field = this._dynamicFields.getElementsByAttribute('fieldname', Zotero.ItemFields.getName(titleFieldID)).item(0);
					if (!field) {
						field = this._dynamicFields.getElementsByAttribute('fieldname', 'itemType').item(0);
					}
					if (field) {
						this._beforeRow = field.parentNode.nextSibling;
						while (this._beforeRow.firstChild.getAttribute('servantLang')) {
							this._beforeRow = this._beforeRow.nextSibling;
						}
					}
					else {
						this._beforeRow = this._dynamicFields.firstChild;
					}
					
					this._creatorCount = -1;
					this._creatorTabCount = -1;
					var num = this.item.numCreators();
					if (num > 0) {
						// Limit number of creators display
						var max = Math.min(num, this._initialVisibleCreators);
						// If fewer than five more, just display
						if (num < max + 5 || this._displayAllCreators) {
							max = num;
						}
						for (var i = 0; i < max; i++) {
							this._creatorCount++;
							this._creatorTabCount++;
							var creator = this.item.getCreator(i);
							var langs = creator.multi.langs();
							var defaultRow = false;
							var multilingualRow = false;
							if (i === (ilen - 1)) {
								var lastCreator = true;
							} else {
								var lastCreator = false;
							}
							var notYetSaved = false;
							if (langs.length) {
								var hasMulti = true;
							} else {
								var hasMulti = false;
							}
							this.buildCreatorRow(creator.ref,
												creator.creatorTypeID,
												defaultRow,
												creator.multi.main,
												multilingualRow,
												lastCreator,
												notYetSaved,
												hasMulti);
							// Assure that every language tag exists. Throw an error
							// on invalid tags.
							for (var j=0,jlen=creator.multi._lst.length;j<jlen;j+=1) {
								// getNickname implicitly adds a tag.
								// Should have a getTag method with the same behaviour.
								var languageTag = creator.multi._lst[j];
								var nickname = Zotero.CachedLanguages.getNickname(languageTag);
								if (!nickname) {
									Zotero.debug("Invalid language tag: "+languageTag);
									continue;
								}
								var myCreator = creator.multi._key[languageTag];
								this._creatorTabCount++;
								var defaultRow = false;
								var multilingualRow = true;
								if (i === (ilen - 1)) {
									var lastCreator = true;
								} else {
									var lastCreator = false;
								}
								var notYetSaved = false;
								var hasMulti = true;
								this.buildCreatorRow(myCreator,
													creator.creatorTypeID,
													defaultRow,
													languageTag,
													multilingualRow,
													lastCreator,
													notYetSaved,
													hasMulti);
							}
							
							// Display "+" button on all but last row
							if (i == max - 2) {
								this.disableCreatorAddButtons();
							}
						}
						// Additional creators not displayed
						if (num > max) {
							this.addMoreCreatorsRow(num - max);
							
							this.disableCreatorAddButtons();
						} else {
							// If we didn't start with creators truncated,
							// don't truncate for as long as we're viewing
							// this item, so that added creators aren't
							// immediately hidden
							this._displayAllCreators = true;
							
							if (this._addCreatorRow) {
								this._creatorCount++;
								this._creatorTabCount++;
								// Add default row
								var defaultRow = false; 
								var languageTag = false;
								var multilingualRow = false;
								var lastCreator = true;
								var notYetSaved = true;
								var hasMulti = false;
								var newname = this.buildCreatorRow(false,
											false,
											defaultRow,
											languageTag,
											multilingualRow,
											lastCreator,
											notYetSaved,
											hasMulti);
                                // XXX This from 4.0 will note work, unfortunately. The code in this file has diverged too far.
								// this.addCreatorRow(false, this.item.getCreator(max-1).creatorTypeID, true); 
								this._addCreatorRow = false;
								this.disableCreatorAddButtons();
							}
						}
					} else if (this.editable && Zotero.CreatorTypes.itemTypeHasCreators(this.item.itemTypeID)) {
						this._creatorCount++;
						this._creatorTabCount++;
						// Add default row
						var defaultRow = true; 
						var languageTag = false;
						var multilingualRow = false;
						var lastCreator = true;
						var notYetSaved = true;
						var hasMulti = false;
						this.buildCreatorRow(false,
											false,
											defaultRow,
											languageTag,
											multilingualRow,
											lastCreator,
											notYetSaved,
											hasMulti);
					}

					// Move to next or previous field if (shift-)tab was pressed
					if (this._lastTabIndex && this._tabDirection) {
						this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
					}
//Zotero.debug("XXX === refresh() === [end]");
				]]>
				</body>
			</method>

			
			<method name="addMultiListener">
				<parameter name="elem"/>
				<body>
				<![CDATA[
				 	elem.addEventListener(
						'click',
						function(event){
							if (event.button === 0) {
								document.getBindingParent(this).prepareMultiPopup(false);
							} else {
								document.getBindingParent(this).prepareMultiPopup(true);
							}
						},
						false
					);
				]]>
				</body>
			</method>

			<method name="prepareMultiPopup">
				<parameter name="isContextMenu"/>
				<body>
				<![CDATA[
					popup = this._multiSpawnPopup;
					if (isContextMenu) {
						popup.childNodes[0].setAttribute('hidden', false);
						popup.childNodes[1].setAttribute('hidden', true);
						this._leftClick = false;
					} else {
						popup.childNodes[0].setAttribute('hidden', true);
						popup.childNodes[1].setAttribute('hidden', false);
						this._leftClick = true;
					}
				]]>
				</body>
			</method>

			
			<method name="buildItemTypeMenu">
				<body>
				<![CDATA[
					if (!this.item) {
						return;
					}
					
					try {
						this.itemTypeMenu.removeAllItems();
					} catch (e) {
						return;
					}
					
					var t = Zotero.ItemTypes.getTypes();
							
					// Sort by localized name
					var itemTypes = [];
					for (var i=0; i<t.length; i++) {
						itemTypes.push({
							id: t[i].id,
							name: t[i].name,
							localized: Zotero.ItemTypes.getLocalizedString(t[i].id)
						});
					}
					var collation = Zotero.getLocaleCollation();
					itemTypes.sort(function(a, b) {
						return collation.compareString(1, a.localized, b.localized);
					});
					
					for (var i=0; i<itemTypes.length; i++) {
						var name = itemTypes[i].name;
						if (name != 'attachment' && name != 'note') {
							this.itemTypeMenu.appendItem(itemTypes[i].localized, itemTypes[i].id);
						}
					}
					
					this.updateItemTypeMenuSelection();
				]]>
				</body>
			</method>
			
			<method name="updateItemTypeMenuSelection">
				<body>
				<![CDATA[
					var listitems = this.itemTypeMenu.firstChild.childNodes;
					for (var i=0, len=listitems.length; i < len; i++) {
						if (listitems[i].getAttribute('value') == this.item.itemTypeID) {
							this.itemTypeMenu.selectedIndex = i;
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="addDynamicRow">
				<parameter name="label"/>
				<parameter name="value"/>
				<parameter name="beforeElement"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX addDynamicRow()");
					var row = document.createElement("row");
					
					// Add click event to row
					var fieldname = value.getAttribute('fieldname');
					if (this._rowIsClickable(fieldname)) {
						row.className = 'zotero-clicky';
						row.addEventListener('click', function (event) {
							document.getBindingParent(this).clickHandler(this);
						}, false);
					}

					row.appendChild(label);
					if (fieldname == 'jurisdiction') {
						value.setAttribute("tooltiptext", value.getAttribute("label"));
						var boxedvalue = document.createElement("hbox");
						boxedvalue.appendChild(value);
						var jurisdictionDefault = document.createElement("checkbox");
						jurisdictionDefault.setAttribute("label","default");
						jurisdictionDefault.setAttribute("id","jurisdiction-default");
						jurisdictionDefault.setAttribute("oncommand","document.getBindingParent(this).jurisdictionDefaultCommand(this);");
						if (this.item.getField("jurisdiction") === Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefault.setAttribute("checked",true);
						}
						boxedvalue.appendChild(jurisdictionDefault);
						row.appendChild(boxedvalue);
					} else {
						row.appendChild(value);
					}
					if (beforeElement) {
						this._dynamicFields.insertBefore(row, this._beforeRow);
					} else {
						this._dynamicFields.appendChild(row);
					}
					return row;
				]]>
				</body>
			</method>
			
			<method name="jurisdictionDefaultCommand">
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var checked = node.getAttribute("checked");
					if (checked) {
						var jurisdictionNode = document.getElementById("jurisdiction-menu");
						var jurisdiction = jurisdictionNode.getAttribute("value");
						Zotero.Prefs.set("import.jurisdictionDefault",jurisdiction);
					} else {
						Zotero.Prefs.set("import.jurisdictionDefault","");
					}
				]]>
			  </body>
			</method>

			<method name="openMultiRow">
			  <parameter name="language"/>
				<body>
				  <![CDATA[
					var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;
					var row = Zotero.getAncestorByTagName(triggerNode, 'row');
					var fieldstring = row.firstChild.getAttribute('fieldname');
					var servantLang = row.firstChild.getAttribute('servantLang');
					if (this._leftClick) {
						if (fieldstring && "creator" === fieldstring.slice(0, 7)) {
							// Creator
							var index = fieldstring.split('-')[1];
							var fieldStringSuffix = fieldstring.split('-')[2];
							var forceTop = false;
							var creator = this.item.getCreator(index);
							creator.multi.changeLangTag(servantLang, language);
							if (fieldStringSuffix === 'typeID') {
								this.item.setCreator(index, creator.ref, creator.creatorTypeID, language, true);
							} else {
								this.item.setCreator(index, creator.multi._key[language], creator.creatorTypeID, language);	
								this.item.removeCreator(index, servantLang);
							}
						} else {
							// Ordinary field
							var fieldname = fieldstring.split('-')[0];
							this.item.multi.changeLangTag(servantLang, language, fieldname);
						}
						this.item.save();
						this.refresh();
					} else if (fieldstring && "creator" === fieldstring.slice(0,7)) {
						this.openMultiCreatorRow(row, language);
					} else {
						this.openMultiFieldRow(row, language);
					}
				]]>
				</body>
			</method>

			<method name="openMultiFieldRow">
			  <parameter name="row"/>
			  <parameter name="language"/>
				<body>
				  <![CDATA[
					var value = false;

					var field = row.firstChild.getAttribute('fieldname');

					var contentNode = row.firstChild.nextSibling;
					if (contentNode.textContent) {
						value = contentNode.textContent;
					} else if (contentNode.getAttribute) {
						value = contentNode.getAttribute('value');
					}
					if (!value) {
						return;
					}

					var fullFieldName = field + "-" + language;

					if (this._clickableFields.indexOf(fullFieldName) == -1) {
						this._clickableFields.push(fullFieldName);
					}

					if (this.item.multi.langs(field).indexOf(language) === -1) {
						// false is for loadIn toggle
						this.item.setField(field, value, false, language);
						this.item.save();
						this.refresh();
					}

					var newrow = this._dynamicFields.getElementsByAttribute('fieldname', fullFieldName).item(0);
					newrow.parentNode.lastChild.click();
				  ]]>
				</body>
			</method>

			<method name="addCreatorRow">
				<parameter name="row"/>
				<parameter name="saveBefore"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX addCreatorRow()");
					var field = row.firstChild.getAttribute('fieldname');
					var index = parseInt(field.replace(/.*-([0-9]+)-.*/,"$1"));
					if (saveBefore) {
						var fields = this.getCreatorFields(row);
						this.modifyCreator(index, fields);

					}
					index++;
					var fullFieldName = "creator-" + index + "-typeID";

					this._creatorCount++;
					this._creatorTabCount++;
					var creatorTypeID = row.firstChild.getAttribute('typeid');
					// For r9096
					//var fieldMode = row.lastChild.firstChild.getAttribute('fieldMode');
					var fieldMode = Zotero.Prefs.get('lastCreatorFieldMode');

					var creator = new Zotero.Creator;
					creator.fieldMode = fieldMode;

					// Second true argument forces insertion rather than edit of creator at this index
					this.item.setCreator(index, creator, creator.creatorTypeID, false, true, true);
					if (this._clickableFields.indexOf(fullFieldName) == -1) {
						this._clickableFields.push(fullFieldName);
					}
					this.refresh();

					var newrow = this._dynamicFields.getElementsByAttribute('fieldname', fullFieldName).item(0);
					newrow.parentNode.lastChild.firstChild.firstChild.click();
				]]>
				</body>
			</method>

			<method name="openMultiCreatorRow">
				<parameter name="row"/>
				<parameter name="lang"/>
				<body>
				<![CDATA[
				// Stuff goes here
//Zotero.debug("XXX openMultiCreatorRow()");
					var field = row.firstChild.getAttribute('fieldname');
					var index = parseInt(field.replace(/.*-([0-9]+)-.*/,"$1"));
					var fullFieldName = "creator-" + index + "-" + lang;
					var oldrow = this._dynamicFields.getElementsByAttribute('fieldname', fullFieldName).item(0);
					if (!oldrow) {
						var creator = this.item.getCreator(index);
						var fields = {
							lastName: creator.ref.lastName,
							firstName: creator.ref.firstName,
							shortName: creator.ref.shortName,
							fieldMode: creator.ref.fieldMode
						}
						creator.multi.setFields(fields, lang);
						this.item.setCreator(index, creator.multi._key[lang], creator.creatorTypeID, lang);
						if (this._clickableFields.indexOf(fullFieldName) == -1) {
							this._clickableFields.push(fullFieldName);
						}
						this.refresh();
					}
					var newrow = this._dynamicFields.getElementsByAttribute('fieldname', fullFieldName).item(0);
					newrow.parentNode.lastChild.firstChild.firstChild.click();
//Zotero.debug("XXX openMultiCreatorRow() [done]");
				]]>
				</body>
			</method>


			<method name="buildCreatorRow">
				<parameter name="creator"/>
				<parameter name="creatorTypeID"/>
				<parameter name="defaultRow"/>
				<parameter name="languageTag"/>
				<parameter name="multilingualRow"/>
				<parameter name="lastCreator"/>
				<parameter name="notYetSaved"/>
				<parameter name="hasMulti"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX buildCreatorRow()");
					// Dummy creator for new entries
					if (!creator) {
						creator = new Zotero.Creator;
					}

					// Use the first entry in the drop-down for the default type if none specified
					var typeID = creatorTypeID ?
						creatorTypeID : this._creatorTypeMenu.childNodes[0].getAttribute('typeid');
					if (defaultRow) {
						creator.fieldMode = Zotero.Prefs.get('lastCreatorFieldMode');
					}

					if (creator.fieldMode == 1) {
						var firstName = '';
						var lastName = creator.lastName;
						if (!lastName) {
							lastName = this._defaultFullName;
						}
					} else {
						var firstName = creator.firstName;
						var lastName = creator.lastName;
						if (!firstName) {
							firstName = this._defaultFirstName;
						}
						if (!lastName) {
							lastName = this._defaultLastName;
						}
					}
					var typeBox = document.createElement("hbox");
					typeBox.setAttribute("typeid", typeID);

					if (this.editable) {
						if (!multilingualRow) {
							typeBox.setAttribute("popup", "creator-type-menu");
							typeBox.setAttribute("contextmenu", "multi-spawn-popup");
						} else {
							typeBox.setAttribute("popup", "multi-spawn-popup");
						}
						this.addMultiListener(typeBox);
					}
					if (!multilingualRow) {
						typeBox.setAttribute("fieldname", 'creator-' + this._creatorCount + '-typeID');
					} else {
						typeBox.setAttribute("fieldname", 'creator-' + this._creatorCount + '-' + languageTag);
					}
					
					if (this.editable) {
						if (multilingualRow) {
							var img = document.createElement('image');
							img.setAttribute('hidden', true);
							typeBox.appendChild(img);
							typeBox.className = 'creator-type-label zotero-langy';
							typeBox.setAttribute('servantLang', languageTag);
						} else {
							typeBox.className = 'creator-type-label zotero-clicky';
						}
					} else {
						if (multilingualRow) {
							typeBox.className = 'creator-type-label zotero-langy';
						} else {
							typeBox.className = 'creator-type-label';
						}
					}
					
					if (multilingualRow) {
						typeBox.setAttribute('servantLang', languageTag);
					}

					var label = document.createElement("label");
					if (multilingualRow) {
						// Will pass undefined to setAttribute() if tag is invalid.
						// Might not be a bad thing; tag label shows as "undefined",
						// and some sensible set of recovery options could be added
						// to the context menu.
						var nickname = Zotero.CachedLanguages.getNickname(languageTag);
						label.setAttribute('value',nickname);
					} else {
						label.setAttribute('value',
							Zotero.getString('creatorTypes.'+Zotero.CreatorTypes.getName(typeID)) + ":");
//OOOO: ??? ok?
						if (languageTag) {
							var nickname = Zotero.CachedLanguages.getNickname(languageTag);
							typeBox.setAttribute('tooltiptext', nickname);
						}
					}
					typeBox.appendChild(label);

					var hbox = document.createElement("hbox");
					hbox.className = 'creator-type-value';
					
					// Name
					var firstlast = document.createElement("hbox");
					firstlast.setAttribute("context", "creator-transform-menu");
					firstlast.className = 'creator-name-box';
					firstlast.setAttribute("flex","1");
					var tabindex = this._tabIndexMinCreators + (this._creatorTabCount * 2);
					var fieldName = 'creator-' + this._creatorCount + '-lastName';
					var lastNameLabel = firstlast.appendChild(
						this.createValueElement(
							lastName,
							fieldName,
							tabindex
						)
					);
					firstlast.lastChild.setAttribute('servantLang', languageTag);
					// flex is set in switchCreatorMode(), invoked below.

					Zotero.setRTL(firstlast.lastChild, [languageTag]);
					
					// Comma
					var comma = document.createElement('label');
					comma.setAttribute('value', ',');
					comma.className = 'comma';
					firstlast.appendChild(comma);
					
					var fieldName = 'creator-' + this._creatorCount + '-firstName';
					firstlast.appendChild(
						this.createValueElement(
							firstName,
							fieldName,
							tabindex + 1
						)
					);
					firstlast.lastChild.setAttribute('servantLang', languageTag);
					// flex is set in switchCreatorMode(), invoked below.

					Zotero.setRTL(firstlast.lastChild, [languageTag]);

					if (creator.fieldMode) {
						firstlast.lastChild.setAttribute('hidden', true);
					}

					this._tabIndexMaxCreators = Math.max(this._tabIndexMaxCreators, tabindex);

					hbox.appendChild(firstlast);
					
					// Single/double field toggle
					var toggleButton = document.createElement('label');
					toggleButton.setAttribute('fieldname',
						'creator-' + this._creatorCount + '-fieldMode');
					toggleButton.className = 'zotero-field-toggle zotero-clicky';
					if (multilingualRow) {
						toggleButton.setAttribute('hidden', true);
					}
					hbox.appendChild(toggleButton);
					
					// Minus (-) button
					var removeButton = document.createElement('label');
					removeButton.setAttribute("value","-");
					removeButton.setAttribute("class","zotero-clicky zotero-clicky-minus");

					// If default first row, don't let user remove it
					// If headline row with multilingual children, ditto
					if (defaultRow || (!multilingualRow && hasMulti)) {
						this.disableButton(removeButton);
					} else {
						removeButton.setAttribute("onclick",
							"document.getBindingParent(this).removeCreator("
							+ this._creatorCount
							+ ", this.parentNode.parentNode)");
					}
					hbox.appendChild(removeButton);

					// Plus (+) button
					var addButton = document.createElement('label');
					addButton.setAttribute("value","+");
					addButton.setAttribute("class", "zotero-clicky zotero-clicky-plus");

					// Disable the "+" button unless this is the very
					// last creator row
					if (multilingualRow) {
						this.disableButton(addButton);
					} else {
						addButton.setAttribute("onclick",
							"document.getBindingParent(this).addCreatorRow(this.parentNode.parentNode, true)");
					}
					
					// If row isn't saved, don't let user add more
					if (notYetSaved) {
						this.disableButton(addButton);
					} 
					hbox.appendChild(addButton);
					
					if (!this.editable) {
						toggleButton.hidden = true;
						removeButton.hidden = true;
						addButton.hidden = true;
					}

					var newRow = this.addDynamicRow(typeBox, hbox, true);


					// Set single/double field toggle mode
					if (creator.fieldMode) {
						this.switchCreatorMode(hbox.parentNode, 1, true, notYetSaved);
					}
					else {
						this.switchCreatorMode(hbox.parentNode, 0, true, notYetSaved);
					}
					return lastNameLabel;
				]]>
				</body>
			</method>
			
			
			<method name="addMoreCreatorsRow">
				<parameter name="num"/>
				<body>
				<![CDATA[
					var box = document.createElement('box');
					
					var label = document.createElement('label');
					label.id = 'more-creators-label';
					label.setAttribute('value', Zotero.getString('general.numMore', num));
					label.setAttribute('onclick',
						"var binding = document.getBindingParent(this); "
						+ "binding._displayAllCreators = true; "
						+ "binding.refresh()"
					);
					
					this.addDynamicRow(box, label, true);
				]]>
				</body>
			</method>
			
			<method name="addDateRow">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="tabindex"/>
				<body>
				<![CDATA[
					var label = document.createElement("label");
					label.setAttribute("value", Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, field) + ':');
					label.setAttribute("fieldname", field);
					label.setAttribute("onclick", "this.nextSibling.firstChild.blur()");
					
					var elem = this.createValueElement(
						Zotero.Date.multipartToStr(value),
						field,
						tabindex
					);
					elem.setAttribute('flex', 1);

					Zotero.setRTL(elem, [this.itemLanguage]);
					
					// y-m-d status indicator
					var datebox = document.createElement('hbox');
					datebox.className = 'zotero-date-field-status';
					var year = document.createElement('label');
					var month = document.createElement('label');
					var day = document.createElement('label');
					year.setAttribute('value', Zotero.getString('date.abbreviation.year'));
					month.setAttribute('value', Zotero.getString('date.abbreviation.month'));
					day.setAttribute('value', Zotero.getString('date.abbreviation.day'));
					
					// Display the date parts we have and hide the others
					var sqldate = Zotero.Date.multipartToSQL(value);
					year.setAttribute('hidden', !Zotero.Date.sqlHasYear(sqldate));
					month.setAttribute('hidden', !Zotero.Date.sqlHasMonth(sqldate));
					day.setAttribute('hidden', !Zotero.Date.sqlHasDay(sqldate));
					
					datebox.appendChild(year);
					datebox.appendChild(month);
					datebox.appendChild(day);
					
					var hbox = document.createElement('hbox');
					hbox.setAttribute('flex', 1);
					hbox.className = "date-box";
					hbox.appendChild(elem);
					hbox.appendChild(datebox);
					
					this.addDynamicRow(label, hbox);
				]]>
				</body>
			</method>

			<method name="switchAllCreatorModes">
			  <parameter name="row"/>
			  <parameter name="fieldMode"/>
			  <parameter name="initial"/>
			  <parameter name="updatePref"/>
			  <body>
				<![CDATA[
					// Basic data
					fieldMode = parseInt(fieldMode, 10);
					var fieldstring = row.firstChild.getAttribute('fieldname');
					var creatorIndex = fieldstring.split('-')[1];
					var creator = this.item.getCreator(creatorIndex);

					if (!creator.ref || (!creator.ref.lastName && !creator.ref.firstName)) {
						this.switchCreatorMode(row, fieldMode, initial, true);
						if (!creator.ref) {
							return;
						}
					}
					
					if (updatePref) {
						// For r9096
						Zotero.Prefs.set('lastCreatorFieldMode', fieldMode);
					}

					// Assemble fields
					var fields = {};
					fields.lastName = creator.ref.lastName;
					fields.firstName = creator.ref.firstName;
					fields.birthYear = creator.ref.birthYear;
					fields.creatorTypeID = creator.creatorTypeID;
					fields.servantLang = creator.multi.main;
					fields.fieldMode = fieldMode;
					fields.forceTop = true;

					// Make adjustments
					if (fieldMode == 1) {
						fields.lastName = [fields.firstName,fields.lastName].join(" ");
						fields.firstName = "";
					} else {
						var lastNameRE = /(.*?)[ ]*([^ ]+[ ]*)$/;
						var parts = lastNameRE.exec(fields.lastName);
						fields.lastName = parts[2];
						fields.firstName = parts[1];
					}
					this.modifyCreator(creatorIndex, fields, false, true);

					for (var langTag in creator.multi._key) {
						fields = {};
						var altcreator = creator.multi._key[langTag];

						fields.lastName = altcreator.lastName;
						fields.firstName = altcreator.firstName;
						fields.birthYear = altcreator.birthYear;
						fields.creatorTypeID = creator.creatorTypeID;
						fields.servantLang = langTag;
						fields.fieldMode = fieldMode;
						fields.forceTop = false;

						if (fieldMode == 1) {
							fields.lastName = [fields.firstName,fields.lastName].join(" ");
							fields.firstName = "";
						} else {
							var lastNameRE = /(.*?)[ ]*([^ ]+[ ]*)$/;
							var parts = lastNameRE.exec(fields.lastName);
							fields.lastName = parts[2];
							fields.firstName = parts[1];
						}
						this.modifyCreator(creatorIndex, fields, false, true);
					}

					this.item.save();
					this.refresh()
				]]>
			  </body>
			</method>

			
			<method name="switchCreatorMode">
				<parameter name="row"/>
				<parameter name="fieldMode"/>
				<parameter name="initial"/>
				<parameter name="deferSave"/>
				<body>
				<![CDATA[
					var fieldstring = row.firstChild.getAttribute('fieldname');
					// Change if button position changes
					// row->hbox->label->label->toolbarbutton
					var button = row.lastChild.lastChild.previousSibling.previousSibling;
					var hbox = button.previousSibling;
					var lastName = hbox.firstChild;
					lastName.setAttribute("flex", "0");
					var comma = hbox.firstChild.nextSibling;
					var firstName = hbox.lastChild;
					firstName.setAttribute("flex", "0");
					// get item box width
					lastName.setAttribute("flex", "1");
					firstName.setAttribute("flex", "1");
					var computedStyle = window.getComputedStyle(row, null);
					var boxWidth = computedStyle.getPropertyValue('width');
					lastName.setAttribute("flex", "0");
					firstName.setAttribute("flex", "0");

						var originalLastName = lastName.value;
						var originalFirstName = firstName.value;
						lastName.value = "dummy";
						lastName.value = originalLastName;
						firstName.value = "dummy";
						firstName.value = originalFirstName;



					// Switch to single-field mode
					if (fieldMode == 1) {
						button.style.backgroundImage = 'url("chrome://zotero/skin/textfield-dual.png")';
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.two'));
						lastName.setAttribute('fieldMode', '1');
						// For r9096
						// button.setAttribute('onclick', "document.getBindingParent(this).switchAllCreatorModes(this.parentNode.parentNode, 0, true)");
						button.setAttribute('onclick', "document.getBindingParent(this).switchAllCreatorModes(this.parentNode.parentNode, 0, false, true)");
						lastName.setAttribute('flex', '1');
						firstName.setAttribute('flex', '0');
						delete lastName.style.width;
						delete lastName.style.maxWidth;
						lastName.setAttribute("tooltiptext", lastName.value);
						
						// Remove firstname field from tabindex
						var tab = parseInt(firstName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', -1);
						if (this._tabIndexMaxCreators == tab) {
							this._tabIndexMaxCreators--;
						}
						
						// Hide first name field and prepend to last name field
						firstName.setAttribute('hidden', true);
						comma.setAttribute('hidden', true);
						
						if (!initial && (this._getFieldValue(firstName) || this._getFieldValue(lastName))) {
							var first = this._getFieldValue(firstName);
							if (first && first != this._defaultFirstName) {
								var last = this._getFieldValue(lastName);
								this._setFieldValue(lastName, first + ' ' + last);
							}
						}
						
						if (this._getFieldValue(lastName) == this._defaultLastName) {
							this._setFieldValue(lastName, this._defaultFullName);
						}
					}
					// Switch to two-field mode
					else {
						button.style.backgroundImage = 'url("chrome://zotero/skin/textfield-single.png")';
						button.setAttribute('tooltiptext', Zotero.getString('pane.item.switchFieldMode.one'));
						lastName.setAttribute('fieldMode', '0');
						// For r9096
						//button.setAttribute('onclick', "document.getBindingParent(this).switchAllCreatorModes(this.parentNode.parentNode, 1, true)");
						button.setAttribute('onclick', "document.getBindingParent(this).switchAllCreatorModes(this.parentNode.parentNode, 1, false, true)");
						
						// appropriately truncate lastName
						// get field label width
						var computedStyle = window.getComputedStyle(row.firstChild, null);
						var leftHboxWidth = computedStyle.getPropertyValue('width');
						// get natural last name width
						computedStyle = window.getComputedStyle(lastName, null);
						var lastNameWidth = computedStyle.getPropertyValue('width');
						if(boxWidth.substr(-2) === 'px'
								&& leftHboxWidth.substr(-2) === 'px'
								&& lastNameWidth.substr(-2) === "px") {
							// compute a maximum width
							boxWidth = parseInt(boxWidth);
							leftHboxWidth = parseInt(leftHboxWidth);
							lastNameWidth = parseInt(lastNameWidth);
							if (button.getAttribute("hidden")) {
								var fixedSpace = 77;
							} else {
								var fixedSpace = 100;
							}
							var maxWidth = boxWidth-leftHboxWidth-fixedSpace-35;
							if(lastNameWidth > maxWidth) {
								lastName.style.width = maxWidth+"px";
								lastName.style.maxWidth = maxWidth+"px";
								lastName.setAttribute("tooltiptext", lastName.value);
							} else {
								delete lastName.style.width;
								delete lastName.style.maxWidth;
								lastName.removeAttribute("tooltiptext");
							}
							// get natural first name width
							//lastName.style.minWidth = "40px";
							lastName.setAttribute('flex', '0');

						var originalLastName = lastName.value;
						var originalFirstName = firstName.value;
						lastName.value = "dummy";
						lastName.value = originalLastName;
						firstName.value = "dummy";
						firstName.value = originalFirstName;
 
						computedStyle = window.getComputedStyle(lastName, null);
						var lastNameWidth = computedStyle.getPropertyValue('width');
							computedStyle = window.getComputedStyle(firstName, null);
							lastNameWidth = parseInt(lastNameWidth);

							var firstNameWidth = computedStyle.getPropertyValue('width');
							firstNameWidth = parseInt(firstNameWidth);

							if (firstNameWidth > (boxWidth-leftHboxWidth-fixedSpace-lastNameWidth)) {
								//firstName.style.width = "40px";
								//firstName.style.maxWidth = "40px";
								firstName.setAttribute("tooltiptext", firstName.value);
							} else {
								firstName.removeAttribute("tooltiptext");
								delete firstName.style.width;
								delete firstName.style.maxWidth;
							}
						}
						
						// Now set the flex and midwidth attributes in earnest
						//lastName.style.minWidth = "40px";
						lastName.setAttribute('flex', '0');

						firstName.style.minWidth = "40px";
						firstName.setAttribute('flex', '1');
						
						var originalLastName = lastName.value;
						var originalFirstName = firstName.value;
						lastName.value = "dummy";
						lastName.value = originalLastName;
						firstName.value = "dummy";
						firstName.value = originalFirstName;

						// Add firstname field to tabindex
						var tab = parseInt(lastName.getAttribute('ztabindex'));
						firstName.setAttribute('ztabindex', tab + 1);
						if (this._tabIndexMaxCreators == tab)
						{
							this._tabIndexMaxCreators++;
						}
						
						if (!initial && (this._getFieldValue(lastName) || this._getFieldValue(firstName))) {
							// Move all but last word to first name field and show it
							var last = this._getFieldValue(lastName);
							if (last && last != this._defaultFullName) {
								var lastNameRE = /(.*?)[ ]*([^ ]+[ ]*)$/;
								var parts = lastNameRE.exec(last);
								if (parts[2] && parts[2] != last)
								{
									this._setFieldValue(lastName, parts[2]);
									this._setFieldValue(firstName, parts[1]);
								}
							}
						}
						
						if (!this._getFieldValue(firstName)) {
							this._setFieldValue(firstName, this._defaultFirstName);
						}
						
						if (this._getFieldValue(lastName) == this._defaultFullName) {
							this._setFieldValue(lastName, this._defaultLastName);
						}
						
						firstName.setAttribute('hidden', false);
						comma.setAttribute('hidden', false);
					}
					
					if (!initial && (this._getFieldValue(firstName) || this._getFieldValue(lastName)))
					{
						var fields = this.getCreatorFields(row);
						fields.fieldMode = fieldMode;

						// NB: The UI assures that this is always a headline entry.
						// (this insurance is probably not required, actually)
						//fields.forceTop = true;

						// Defer item save?
						var fieldstring = row.firstChild.getAttribute('fieldname');
						var creatorIndex = fieldstring.split('-')[1];
						this.modifyCreator(creatorIndex, fields, false, deferSave);
					}
				]]>
				</body>
			</method>
			
			
			<method name="scrollToTop">
				<body>
				<![CDATA[
					// DEBUG: Valid nsIScrollBoxObject but methods return errors
					return;
					
					var sbo = document.getAnonymousNodes(this)[0].boxObject;
					sbo.QueryInterface(Components.interfaces.nsIScrollBoxObject);
					sbo.scrollTo(0,0);
				]]>
				</body>
			</method>
			
			
			<method name="ensureElementIsVisible">
				<parameter name="elem"/>
				<body>
				<![CDATA[
					var sbo = document.getAnonymousNodes(this)[0].boxObject;
					sbo.QueryInterface(Components.interfaces.nsIScrollBoxObject);
					sbo.ensureElementIsVisible(elem);
				]]>
				</body>
			</method>
			
			<method name="changeTypeTo">
				<parameter name="itemTypeID"/>
				<parameter name="menu"/>
				<body>
				<![CDATA[
					if (itemTypeID == this.item.itemTypeID) {
						return true;
					}

					var fieldsToDelete = this.item.getFieldsNotInType(itemTypeID, true);
					
					// Special cases handled below
					var bookTypeID = Zotero.ItemTypes.getID('book');
					var bookSectionTypeID = Zotero.ItemTypes.getID('bookSection');
					
					// Add warning for shortTitle when moving from book to bookSection
					// when title will be transferred
					if (this.item.itemTypeID == bookTypeID && itemTypeID == bookSectionTypeID) {
						var titleFieldID = Zotero.ItemFields.getID('title');
						var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
						if (this.item.getField(titleFieldID) && this.item.getField(shortTitleFieldID)) {
							if (!fieldsToDelete) {
								fieldsToDelete = [];
							}
							fieldsToDelete.push(shortTitleFieldID);
						}
					}
					
					// Generate list of localized field names for display in pop-up
					if (fieldsToDelete) {
						// Ignore warning for bookTitle when going from bookSection to book
						// if there's not also a title, since the book title is transferred
						// to title automatically in Zotero.Item.setType()
						if (this.item.itemTypeID == bookSectionTypeID && itemTypeID == bookTypeID) {
							var titleFieldID = Zotero.ItemFields.getID('title');
							var bookTitleFieldID = Zotero.ItemFields.getID('bookTitle');
							var shortTitleFieldID = Zotero.ItemFields.getID('shortTitle');
							if (this.item.getField(bookTitleFieldID) && !this.item.getField(titleFieldID)) {
								var index = fieldsToDelete.indexOf(bookTitleFieldID);
								fieldsToDelete.splice(index, 1);
								// But warn for short title, which will be removed
								if (this.item.getField(shortTitleFieldID)) {
									fieldsToDelete.push(shortTitleFieldID);
								}
							}
						}
						
						var fieldNames = "";
						for (var i=0; i<fieldsToDelete.length; i++) {
							fieldNames += "\n - " +
								Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, fieldsToDelete[i]);
						}
						
						var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
							.getService(Components.interfaces.nsIPromptService);
					}
					
					if (!fieldsToDelete || fieldsToDelete.length == 0 ||
							promptService.confirm(null,
								Zotero.getString('pane.item.changeType.title'),
								Zotero.getString('pane.item.changeType.text') + "\n" + fieldNames)) {

						this.item.setType(itemTypeID);
						
						// Force jurisdiction value if required
						this.forceJurisdiction(itemTypeID);
						
						if (this.saveOnEdit) {
							this.item.save();
							this.refresh();
						}
						else {
							this.refresh();
						}
						
						if (this.eventHandlers['itemtypechange'] && this.eventHandlers['itemtypechange'].length) {
							var self = this;
							this.eventHandlers['itemtypechange'].forEach(function (f) f.bind(self)());
						}
						
						return true;
					}
					return false;
				]]>
				</body>
			</method>
			
			<method name="forceJurisdiction">
				<parameter name="itemTypeID"/>
				<body>
				<![CDATA[
						// XXXX Factor this out to a function. It will be used in two places.
						var jurisdictionID = Zotero.ItemFields.getID('jurisdiction');
						var fields = Zotero.ItemFields.getItemTypeFields(itemTypeID);
						if (fields.indexOf(jurisdictionID) > -1) {
							var itemType = Zotero.ItemTypes.getName(itemTypeID);
							if (["report","newspaperArticle","journalArticle"].indexOf(itemType) === -1) {
								if (!this.item.getField(jurisdictionID)) {
									var jurisdictionDefault = Zotero.Prefs.get("import.jurisdictionDefault");
									var jurisdictionFallback = Zotero.Prefs.get("import.jurisdictionFallback");
									if (jurisdictionDefault) {
										this.item.setField(jurisdictionID,jurisdictionDefault);
									} else if (jurisdictionFallback) {
										this.item.setField(jurisdictionID,jurisdictionFallback);
									} else {
										this.item.setField(jurisdictionID,"us");
									}
								}
							}
						}
				]]>
				</body>
			</method>

			
			<method name="toggleAbstractExpand">
				<parameter name="label"/>
				<body>
				<![CDATA[
					var cur = Zotero.Prefs.get('lastAbstractExpand');
					Zotero.Prefs.set('lastAbstractExpand', !cur);
					
					var ab = label.nextSibling;
					var valueText = this.item.getField('abstractNote');
					var tabindex = ab.getAttribute('ztabindex');
					var elem = this.createValueElement(
						valueText,
						'abstractNote',
						tabindex
					);
					ab.parentNode.replaceChild(elem, ab);
					
					var text = Zotero.ItemFields.getLocalizedString(this.item.itemTypeID, 'abstractNote') + ':';
					// Add '(...)' before "Abstract:" for collapsed abstracts
					if (valueText && cur) {
						text = '(...) ' + text;
					}
					label.setAttribute('value', text);
				]]>
				</body>
			</method>
			
			
			<method name="disableButton">
				<parameter name="button"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', true);
					button.setAttribute('onclick', false); 
				]]>
				</body>
			</method>
			
			
			<method name="_enablePlusButton">
				<parameter name="button"/>
				<body>
				<![CDATA[
					button.setAttribute('disabled', false);
					button.setAttribute("onclick",
						+ "var row = Zotero.getAncestorByTagName(this, 'row'); " +
						+ "document.getBindingParent(this).addCreatorRow(row, true);");
// Trunk patch circa r10379-r10414 has this:
//+						+ "parent.disableButton(this); "
// and then this:
//+						+ "parent.addCreatorRow("
//+							+ "creator, "
//+							+ (creatorTypeID ? creatorTypeID : 'false') + ", true"
//+						+ ");"
//+					);
				]]>
				</body>
			</method>
			
			
			<method name="disableCreatorAddButtons">
				<body>
				<![CDATA[
					// Disable the "+" button on all creator rows
					var elems = this._dynamicFields.getElementsByAttribute('value', '+');
					for (var i = 0, len = elems.length; i < len; i++) {
						this.disableButton(elems[i]);
					}
				]]>
				</body>
			</method>


			<method name="showJurisdictionEditor">
				<parameter name="node"/>
				<body>
				<![CDATA[
					var tabindex = node.getAttribute("ztabindex");

					var value = node.getAttribute('label');
					var textbox = document.createElement('textbox');
					textbox.setAttribute("ztabindex", tabindex);
					textbox.setAttribute('value',value);
					textbox.setAttribute("oldComment",node.getAttribute("value"));
					textbox.setAttribute("oldValue",node.getAttribute("label"));
					textbox.setAttribute("flex","1");
					textbox.setAttribute('emptytext','Enter a jurisdiction');
					textbox.setAttribute('type','autocomplete');
					textbox.setAttribute('autocompletesearch','zotero');
					textbox.setAttribute('autocompletesearchparam','{"fieldName":"jurisdictions"}');
					textbox.setAttribute('onkeypress','document.getBindingParent(this).handleJurisdictionKeypress(event);');
					textbox.setAttribute('ontextentered','document.getBindingParent(this).handleJurisdictionAutoCompleteSelect(this)');
					node.parentNode.replaceChild(textbox, node)
					textbox.addEventListener('blur', function (event) {
						document.getBindingParent(this).hideJurisdictionEditor(this);
					}, false);
					 textbox.select();
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
				]]>
				</body>
			</method>


			<method name="handleJurisdictionKeypress">
				<parameter name="event"/>
				<body>
				<![CDATA[
				   //alert(textbox.mController);
				   var target = event.target;
				   var focused = document.commandDispatcher.focusedElement;
					
				   switch (event.keyCode) {
					 case event.DOM_VK_ESCAPE:
					 case event.DOM_VK_RETURN:
					   event.preventDefault();
					   event.target.blur();
					   break;
					 case event.DOM_VK_TAB:
					   this._tabDirection = event.shiftKey ? -1 : 1;
					   this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
					   event.preventDefault();
					   return true;
				   }
				   return false;
				]]>
				</body>
			</method>

			<method name="hideJurisdictionEditor">
				<parameter name="node"/>
				<parameter name="result"/>
				<body>
				<![CDATA[
				  if (!result) {
				  	var itemType = Zotero.ItemTypes.getName(this.item.itemTypeID);
				  	if (["report","newspaperArticle","journalArticle"].indexOf(itemType) == -1) {
				  		result = {val:node.getAttribute("oldValue"),comment:node.getAttribute("oldComment")};
				  	} else {
				  		result = {val:"",comment:""};
				  	}
				  }
				  var tabindex = node.setAttribute("ztabindex", tabindex);

				  var valueElement = document.createElement("menulist");
				  valueElement.setAttribute("id","jurisdiction-menu");
				  valueElement.setAttribute("ztabindex", tabindex);
				  valueElement.setAttribute("flex","1");
				  valueElement.setAttribute("class", "zotero-clicky");
				  valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
				  valueElement.setAttribute("value",result.comment);
				  valueElement.setAttribute("label",result.val);
				  valueElement.setAttribute("tooltiptext",result.val);
				  node.parentNode.replaceChild(valueElement,node);
				  this.setJurisdictionKey(result.comment, valueElement);
/*
					if (this._tabDirection) {
						if (!focusMode) {
							var focusMode = 'info';
							var focusBox = this._dynamicFields;
						}
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
*/
				]]>
				</body>
			</method>


			<method name="handleJurisdictionAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
				  var result;
				  if (textbox.value) {
				   	// Comment is the tag code, value is the tag description
				   	result = this.getJurisdictionResult(textbox);
				  }
				  // Close editor
				  // comment = key
				  // val = description
				  this.hideJurisdictionEditor(textbox, result);
				]]>
				</body>
			</method>

			<method name="getJurisdictionResult">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
				  var controller = textbox.controller;
				  for (var i=0; i<controller.matchCount; i++) {
				  	if (controller.getValueAt(i) == textbox.value) {
						return {val:controller.getValueAt(i),comment:controller.getCommentAt(i)};
					}
				  }
				  return false;
				]]>
				</body>
			</method>


			<method name="createValueElement">
				<parameter name="valueText"/>
				<parameter name="fieldName"/>
				<parameter name="tabindex"/>
				<body>
				<![CDATA[
					valueText = valueText + '';

					// Used to get the fieldID, and to determine if the element 
					// deserves a field menu
					var shortFieldName = fieldName.split('-')[0];
					
					if (shortFieldName) {
						var fieldID = Zotero.ItemFields.getID(shortFieldName);
					}
					
					// If an abstract, check last expand state
					var abstractAsVbox = fieldName == 'abstractNote' && Zotero.Prefs.get('lastAbstractExpand');
					
					// Use a vbox for multiline fields (but Abstract only if it's expanded)
					var useVbox = (fieldName != 'abstractNote' || abstractAsVbox)
						&& Zotero.ItemFields.isMultiline(fieldName);
					
					if (fieldName === 'jurisdiction') {
						var valueElement = document.createElement("menulist");
						valueElement.setAttribute("id","jurisdiction-menu");
						// XXXX Set default here if req.
						this.forceJurisdiction(this.item.itemTypeID);
						var value = this.item.getField("jurisdiction",true);
						if (value) {
							var label = Zotero.DB.valueQuery("SELECT jurisdictionName FROM jurisdictions WHERE jurisdictionID=?",[value]);
							if (!label) {
								label = value;
								valueElement.setAttribute("style","background:yellow;");
							}
							valueElement.setAttribute("label", label);
							valueElement.setAttribute("value", value);
						}
					}
					else if (useVbox) {
						var valueElement = document.createElement("vbox");
					}
					else {
						var valueElement = document.createElement("label");
					}
					valueElement.setAttribute('fieldname', fieldName);
					valueElement.setAttribute('flex', 1);
					valueElement.setAttribute('ztabindex', tabindex);
					
					if (this._fieldIsClickable(fieldName)) {
						if (fieldName == 'jurisdiction') {
							valueElement.setAttribute("onclick","document.getBindingParent(this).showJurisdictionEditor(this);");
							valueElement.className = 'zotero-clicky';
							return valueElement;
						} else {
							valueElement.addEventListener('click', function (event) {
								/* Skip right-click on Windows */
								if (event.button) {
									return;
								}
								document.getBindingParent(this).clickHandler(this);
							}, false);
						}
						valueElement.className = 'zotero-clicky';
					}
					switch (fieldName) {
						case 'itemType':
							valueText = Zotero.ItemTypes.getLocalizedString(valueText);
							valueElement.setAttribute('itemTypeID', valueText);
							break;
						
						case 'tag':
							this._tabIndexMaxTagsFields = Math.max(this._tabIndexMaxTagsFields, tabindex);
							break;
						
						// Convert dates from UTC
						case 'dateAdded':
						case 'dateModified':
						case 'accessDate':
						
						// TEMP - NSF
						case 'dateSent':
						case 'dateDue':
						case 'accepted':
							if (valueText) {
								var date = Zotero.Date.sqlToDate(valueText, true);
								if (date) {
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(valueText)) {
										date = Zotero.Date.sqlToDate(valueText);
										valueText = date.toLocaleDateString();
									}
									else {
										valueText = date.toLocaleString();
									}
								}
								else {
									valueText = '';
								}
							}
							break;
					}

					if (fieldID) {
						// Display the SQL date as a tooltip for date fields
						// TEMP - filingDate
						if (Zotero.ItemFields.isFieldOfBase(fieldID, 'date') 
							|| ['filingDate','priorityDate','publicationDate','originalDate','signingDate','openingDate','adoptionDate','newsCaseDate','conferenceDate'].indexOf(fieldName) > -1) {

							valueElement.setAttribute('tooltiptext',
								Zotero.Date.multipartToSQL(this.item.getField(fieldName, true)));
						}
						
						// Display a context menu for certain fields
						if (this.editable && (shortFieldName == 'seriesTitle' || fieldName == 'shortTitle' ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'title') ||
								Zotero.ItemFields.isFieldOfBase(fieldID, 'publicationTitle'))) {
							valueElement.setAttribute('contextmenu', 'zotero-field-transform-menu');
						}
					}
					
					var firstSpace = valueText.indexOf(" ");
					
					// To support newlines in Abstract and Extra fields, use multiple
					// <description> elements inside a vbox
					if (useVbox) {
						var lines = valueText.split("\n");
						for (var i = 0; i < lines.length; i++) {
							var descriptionNode = document.createElement("description");
							// Add non-breaking space to empty lines to prevent them from collapsing.
							// (Just using CSS min-height results in overflow in some cases.)
							if (lines[i] === "") {
								lines[i] = "\u00a0";
							}
							var linetext = document.createTextNode(lines[i]);
							descriptionNode.appendChild(linetext);
							valueElement.appendChild(descriptionNode);
						}
					}
					// 29 == arbitrary length at which to chop uninterrupted text
					else if ((firstSpace == -1 && valueText.length > 29 ) || firstSpace > 29
						|| (fieldName &&
							(fieldName.substr(0, 7) == 'creator') || fieldName == 'abstractNote')) {
						if (fieldName == 'abstractNote') {
							valueText = valueText.replace(/[\t\n]/g, ' ');
						}
						valueElement.setAttribute('crop', 'end');
						valueElement.setAttribute('value',valueText);
					}
					else {
						// Wrap to multiple lines
						valueElement.appendChild(document.createTextNode(valueText));
					}
					
					return valueElement;
				]]>
				</body>
			</method>
			
			
			<method name="removeCreator">
				<parameter name="index"/>
				<parameter name="row"/>
				<body>
				<![CDATA[
					// If unsaved row, just remove element
					if (!this.item.hasCreatorAt(index)) {
						this._dynamicFields.removeChild(row);
						
						// Enable the "+" button on the previous row
						var elems = this._dynamicFields.getElementsByAttribute('value', '+');
	// Code below would replace this:
						if (elems && elems.length) {
							var button = elems[elems.length-1];
							this._enablePlusButton(button);
						}
/*
	// This has come in from 4.0.
	// The UI code has diverged too much to adopt it here.
						var button = elems[elems.length-1];
						var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(button, 'row'));
						this._enablePlusButton(button, creatorFields.creatorTypeID, creatorFields.fieldMode);
*/						
						this._creatorCount--;
						this._creatorTabCount--;
					} else {
						// Delete from multi we are a multilingual entry,
						// otherwise delete the entire creator.
						var fieldstring = row.firstChild.getAttribute('fieldname');
						var fieldStringSuffix = fieldstring.split('-')[2];
						if (fieldStringSuffix === 'typeID') {
							var forceTop = true;
						} else {
							var forceTop = false;
						}
						var languageTag = row.firstChild.getAttribute('servantLang');
						this.item.removeCreator(index, languageTag, forceTop);
						this.item.save();
					}
					this.refresh();
				]]>
				</body>
			</method>
			
			<method name="showEditor">
				<parameter name="elem"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX showEditor() [start]");
					// Blur any active fields
					if (this._dynamicFields) {
						this._dynamicFields.focus();
					}
					
					Zotero.debug('Showing editor');
					
					var row = Zotero.getAncestorByTagName(elem, 'row');
					var servantLang = row.firstChild.getAttribute('servantLang');

					var fieldName = elem.getAttribute('fieldname');
					var tabindex = elem.getAttribute('ztabindex');
					
					if (fieldName) {
						var m = fieldName.match(/^([a-zA-Z]*)(?:-([0-9]+)-(firstName|lastName))*$/);
						if (m) {
							var field = m[1];
							if (m[2]) {
								var creatorIndex = m[2];
								var creatorField = m[3];
							}
						}
					}

					var langs = [this.itemLanguage];

					if (field == 'creator') {
						var c = this.item.getCreator(creatorIndex);
						var value = c ? c.multi.get(creatorField, servantLang) : '';
						var itemID = this.item.id;
						if (servantLang) {
							langs.push(servantLang);
						} else if (c && c.multi) {
							langs.push(c.multi.main)
						}
					}
					else if (fieldName=='tag') {
						var tagID = elem.parentNode.getAttribute('id').split('-')[1];
						var value = tagID ? Zotero.Tags.getName(tagID) : '';
						var itemID = Zotero.getAncestorByTagName(elem, 'tagsbox').item.id;
					}
					else {
// OOOOO: This can all be simplified, back pretty much to the monolingual
// version, then with a few small tweaks.
						// ZZZ Same code is used once more below.
						var m = fieldName.match(/^([a-zA-Z]+)(?:-(.*))*/);
						fieldStub = m[1];
						fieldLanguage = m[2];
						if (Zotero.multiFieldNames[fieldStub] && fieldLanguage) {
							var value = this.item.multi.get(fieldStub, fieldLanguage, true);
						} else {
							var value = this.item.getField(fieldName);
						}
						var itemID = this.item.id;
						
						// Access date needs to be converted from UTC
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									// If no time, interpret as local, not UTC
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
									}
									else {
										var localDate = Zotero.Date.sqlToDate(value, true);
									}
									var value = Zotero.Date.dateToSQL(localDate);
									
									// Don't show time in editor
									value = value.replace(' 00:00:00', '');
									break;
							}
						}

						if (Zotero.multiFieldNames[fieldStub]) {
							if (servantLang) {
								langs.push(servantLang);
							} else {
								var fieldID = Zotero.ItemFields.getID(fieldStub);
								langs.push(this.item.multi.main[fieldID]);
							}
						}
					}
					
					var t = document.createElement("textbox");
					t.setAttribute('value', value);
					t.setAttribute('fieldname', fieldName);
					t.setAttribute('ztabindex', tabindex);
					t.setAttribute("flex", "1");

					Zotero.setRTL(t, langs);
					
					if (field === 'creator') {
						t.setAttribute('fieldMode', elem.getAttribute('fieldMode'));
						if (creatorField=='lastName') {
							elem.parentNode.lastChild.style.maxWidth = "40px";
							elem.parentNode.lastChild.setAttribute('flex', '1');
						} else {
							elem.parentNode.firstChild.style.maxWidth = "40px";
						}
					}
					
					var fieldNameX = fieldName.replace(/-.*$/,"");
					if (Zotero.ItemFields.isMultiline(fieldNameX) || Zotero.ItemFields.isLong(fieldNameX)) {
						t.setAttribute('multiline', true);
						t.setAttribute('rows', 8);
					}
					else {
						// Add auto-complete for certain fields
						if (Zotero.ItemFields.isAutocompleteField(fieldName)
								|| fieldName == 'creator'
								|| fieldName == 'tag') {
							t.setAttribute('type', 'autocomplete');
							t.setAttribute('autocompletesearch', 'zotero');
							
							let params = {
								fieldName: fieldName,
								libraryID: this.item.libraryID
							};
							if (field == 'creator') {
								params.fieldMode = parseInt(elem.getAttribute('fieldMode'));
								
								// Include itemID and creatorTypeID so the autocomplete can
								// avoid showing results for creators already set on the item
								let row = Zotero.getAncestorByTagName(elem, 'row');
								let creatorTypeID = parseInt(
									row.getElementsByClassName('creator-type-label')[0]
									.getAttribute('typeid')
								);
								if (itemID) {
									params.itemID = itemID;
									params.creatorTypeID = creatorTypeID;
								}
							};
							t.setAttribute(
								'autocompletesearchparam', JSON.stringify(params)
							);
							t.setAttribute('ontextentered',
								'document.getBindingParent(this).handleCreatorAutoCompleteSelect(this)');
						}
					}
					var box = elem.parentNode;
					box.replaceChild(t, elem);
					
					// Prevent error when clicking between a changed field
					// and another -- there's probably a better way
					if (!t.select) {
						return;
					}
					
					t.select();
					
					t.addEventListener('blur', function (event) {
						document.getBindingParent(this).blurHandler(this);
					}, false);
					t.setAttribute('onkeypress', "return document.getBindingParent(this).handleKeyPress(event);");
					
					this._tabDirection = false;
					this._lastTabIndex = tabindex;
//Zotero.debug("XXX showEditor() [end]");
					return t;
				]]>
				</body>
			</method>
			
			
			<!--
			 Save a multiple-field selection for the creator autocomplete
			 (e.g. "Shakespeare, William")
			-->
			<method name="handleCreatorAutoCompleteSelect">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
					var creatorID;
					var numFields = 0;
					var comment = false;
					var controller = textbox.controller;
					
					for (var i=0; i<controller.matchCount; i++)
					{
						if (controller.getValueAt(i) == textbox.value)
						{
							comment = controller.getCommentAt(i);
							var [creatorID, numFields] = comment.split('-');
							break;
						}
					}

					// If result uses two fields, save both
					if (numFields==2)
					{
						// Manually clear autocomplete controller's reference to
						// textbox to prevent error next time around
						textbox.mController.input = null;
						
						var [field, creatorIndex, creatorField] =
							textbox.getAttribute('fieldname').split('-');
						
						// Stay focused
						this._lastTabIndex = parseInt(textbox.getAttribute('ztabindex')) - 1;
						this._tabDirection = 1;
						
						var creator = Zotero.Creators.get(creatorID);
						
						var otherField = creatorField == 'lastName' ? 'firstName' : 'lastName';
						
						// Update this textbox
						textbox.setAttribute('value', creator[creatorField]);
						textbox.value = creator[creatorField];
						
						// Update the other label
						if (otherField=='firstName'){
							var label = textbox.nextSibling.nextSibling;
						}
						else if (otherField=='lastName'){
							var label = textbox.previousSibling.previousSibling;
						}
						
						//this._setFieldValue(label, creator[otherField]);
						if (label.firstChild){
							label.firstChild.nodeValue = creator[otherField];
						}
						else {
							label.value = creator[otherField];
						}
						
						var row = Zotero.getAncestorByTagName(textbox, 'row');
						
						var fields = this.getCreatorFields(row);

// ??? Doesn't this mean no modification will take place???  Or not???

						fields[creatorField] = creator[creatorField];
						fields[otherField] = creator[otherField];

						this.modifyCreator(creatorIndex, fields);
					}
					
					// Otherwise let the autocomplete popup handle matters
				]]>
				</body>
			</method>
			
			
			<method name="handleKeyPress">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var target = event.target;
					var focused = document.commandDispatcher.focusedElement;

					switch (event.keyCode)
					{
						case event.DOM_VK_RETURN:
							var fieldname = target.getAttribute('fieldname');
							// Use shift-enter as the save action for the larger fields
							if (Zotero.ItemFields.isMultiline(fieldname) 
								&& !event.shiftKey 
								&& !Zotero.ItemFields.isFieldOfBase(fieldname, 'title')) {

								break;
							}
							
							
							// Prevent blur on containing textbox
							// DEBUG: what happens if this isn't present?
							event.preventDefault();
							
							if (fieldname == 'tag')
							{
								// If last tag row, create new one
								var row = target.parentNode.parentNode;
								if (row == row.parentNode.lastChild)
								{
									this._tabDirection = 1;
									var lastTag = true;
								}
							}
							// Shift-enter adds new creator row
							else if (fieldname.indexOf('creator-') == 0 && event.shiftKey) {
								// Value hasn't changed
								if (target.getAttribute('value') == target.value) {
									// If + button is disabled, just focus next creator row
									var row = Zotero.getAncestorByTagName(target, 'row');
									if (row.lastChild.lastChild.disabled) {
										this._focusNextField(this._dynamicFields, this._lastTabIndex, false);
									}
									else {
										// TODO: should use current creator type
										this.addCreatorRow(row);
                                        // XXX This from 4.0 will not work, unfortunately. The code in this file has diverged too far.
										// var creatorFields = this.getCreatorFields(Zotero.getAncestorByTagName(target, 'row'));
										// this.addCreatorRow(false, creatorFields.creatorTypeID, true);
									}
								}
								// Value has changed
								else {
									// OOOOO: Is this odd?  Can't we just save a let refresh()
									// do the rest?
									this._tabDirection = 1;
									this.item.save()
									this._addCreatorRow = true;
									focused.blur();
								}
								return false;
							}
							focused.blur();
							
							// Return focus to items pane
							if (!lastTag) {
								var tree = document.getElementById('zotero-items-tree');
								if (tree) {
									tree.focus();
								}
							}
							
							return false;
							
						case event.DOM_VK_ESCAPE:
							// Reset field to original value
							target.value = target.getAttribute('value');
							
							var tagsbox = Zotero.getAncestorByTagName(focused, 'tagsbox');
							
							focused.blur();
							
							if (tagsbox) {
								tagsbox.closePopup();
							}
							
							// Return focus to items pane
							var tree = document.getElementById('zotero-items-tree');
							if (tree) {
								tree.focus();
							}
							
							return false;
							
						case event.DOM_VK_TAB:
							this._tabDirection = event.shiftKey ? -1 : 1;
							var fieldstring = target.getAttribute('fieldname');
							var fieldName = fieldstring.split('-')[0];
							if (fieldName === 'creator') {
								var fieldMode = target.getAttribute('fieldMode');
								var fieldSubName = fieldstring.split('-')[2];
								if (fieldMode == "0" && fieldSubName === 'lastName' && this._tabDirection === 1) {
									this._deferCreatorSave = true;
								}
							}
							this._focusNextField(this._dynamicFields, this._lastTabIndex, this._tabDirection == -1);
							this._deferCreatorSave = false;
							event.preventDefault();
							return true;
					}
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="itemTypeMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					if (!event.shiftKey) {
						this.focusFirstField('info');
						event.preventDefault();
					}
					// Shift-tab
					else {
						this._tabDirection = false;
					}
 				]]>
 				</body>
			</method>
			
			<method name="jurisdictionMenuTab">
				<parameter name="event"/>
				<body>
				<![CDATA[
					var elem = event.target;
					var ztabindex = elem.getAttribute("ztabindex");
					var tabindex = parseInt(elem.getAttribute("ztabindex"),10);
					if (!event.shiftKey) {
						tabindex += 1;
					} else {
						// Shift-tab
						tabindex += -1;
					}
					var nextelem = this._dynamicFields.getElementsByAttribute("ztabindex",tabindex)[0];
					nextelem.click();
					event.preventDefault();
 				]]>
 				</body>
			</method>
			
			

			<method name="hideEditor">
				<parameter name="textbox"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX hideEditor() [start]");
				try {
					/*
					var textbox = Zotero.getAncestorByTagName(t, 'textbox');
					if (!textbox){
						Zotero.debug('Textbox not found in hideEditor');
						return;
					}
					*/
					
					var row = Zotero.getAncestorByTagName(textbox, 'row');
					var servantLang = row.firstChild.getAttribute('servantLang');

					var changed = false;
					if (textbox.value !== textbox.getAttribute('value')) {
						changed = true;
					}
					
					// TODO: get rid of this?
					var saveChanges = this.saveOnEdit;
					
					// Prevent autocomplete breakage in Firefox 3
					if (textbox.mController) {
						textbox.mController.input = null;
					}
					
					var fieldName = textbox.getAttribute('fieldname');
					var tabindex = textbox.getAttribute('ztabindex');
					
					//var value = t.value;
					var value = textbox.value;

					var elem;
					
					if (fieldName) {
						var m = fieldName.match(/^([a-zA-Z]*)(?:-([0-9]+)-(firstName|lastName))*$/);
						if (m) {
							var field = m[1];
							if (m[2]) {
								var creatorIndex = m[2];
								var creatorField = m[3];
							}
						}
					}

					// Creator fields
					if (field == 'creator') {


						var otherFields = this.getCreatorFields(row);

						// deferSave=true will be overidden if the item has been
						// saved previously.
						//var deferSave = this._deferCreatorSave;
						// Well, no, don't defer. Period.
						deferSave = false;
						this.modifyCreator(creatorIndex, otherFields, false, deferSave);
						
						var c = this.item.getCreator(creatorIndex);

						// multi.get is robust, or should be
						if (c && c.ref.id) {
							var val = c ? c.multi.get(creatorField, servantLang) : null;
						} else {
							if (!otherFields.lastName && !otherFields.firstName) {
								this.removeCreator(creatorIndex, row);
								return;
							}
							var val = false;
						}
						
						if (!val) {
							// Reset to '(first)'/'(last)'/'(name)'
							if (creatorField == 'lastName') {
								val = otherFields.fieldMode
									? this._defaultFullName : this._defaultLastName;
							}
							else if (creatorField == 'firstName') {
								val = this._defaultFirstName;
							}
						}
						elem = this.createValueElement(
							val,
							fieldName,
							tabindex
						);
						// Carry across the fieldMode
						// (prevents change to fieldMode when field is saved
						// with no change twice in succession)
						elem.setAttribute('fieldMode',textbox.getAttribute('fieldMode'));

						var box = textbox.parentNode;
						if (creatorField=='lastName') {
							box.lastChild.style.minWidth = null;
							box.lastChild.style.maxWidth = null;
							box.lastChild.style.width = null;
						} else {
							box.firstChild.style.minWidth = null;
							box.firstChild.style.maxWidth = null;
							box.firstChild.style.width = null;
						}
					}
					
					// Tags
					else if (fieldName=='tag') {
						var tagsbox = Zotero.getAncestorByTagName(textbox, 'tagsbox');
						if (!tagsbox)
						{
							Zotero.debug('Tagsbox not found', 1);
							return;
						}
						
						var row = textbox.parentNode;
						var rows = row.parentNode;
						
						// Tag id encoded as 'tag-1234'
						var id = row.getAttribute('id').split('-')[1];
						
						if (saveChanges) {
							if (id) {
								if (value) {
									// If trying to replace with another existing tag
									// (which causes a delete of the row),
									// clear the tab direction so we don't advance
									// when the notifier kicks in
									var existing = Zotero.Tags.getID(value, 0);
									if (existing && id != existing)
									{
										this._tabDirection = false;
									}
									var changed = tagsbox.replace(id, value);
									if (changed)
									{
										return;
									}
								}
								else {
									tagsbox.remove(id);
									return;
								}
							}
							// New tag
							else {
								// If this is an existing automatic tag, it's going to be
								// deleted and the number of rows will stay the same,
								// so we have to compensate
								var existingTypes = Zotero.Tags.getTypes(value);
								if (existingTypes && existingTypes.indexOf(1) != -1) {
									this._lastTabIndex--;
								}
								var id = tagsbox.add(value);
							}
						}
						
						if (id) {
							elem = this.createValueElement(
								value,
								'tag',
								tabindex
							);
						}
						else {
							// Just remove the row
							//
							// If there's an open popup, this throws NODE CANNOT BE FOUND
							try {
								var row = rows.removeChild(row);
							}
							catch (e) {}
							tagsbox.fixPopup();
							tagsbox.closePopup();
							
							this._tabDirection = false;
							return;
						}
						
						var focusMode = 'tags';
						var focusBox = tagsbox;
					}
					
					// Fields
					else {
						// Spoof field names, to clear isFieldOfBase() below.
						// This ain't great; fieldLanguage may return a value
						// even though fieldStub is not a multilingual
						// static field, so we need to screen on fieldStub
						// when this is used.
						var m = fieldName.match(/^([a-zA-Z]+)(?:-(.*))*/);
						fieldStub = m[1];
						fieldLanguage = m[2];

						// Access date needs to be parsed and converted to UTC
						if (value != '') {
							switch (fieldName) {
								case 'accessDate':
									// If just date, don't convert to UTC
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else if (Zotero.Date.isSQLDateTime(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate, true);
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								// TEMP - NSF
								case 'dateSent':
								case 'dateDue':
								case 'accepted':
									if (Zotero.Date.isSQLDate(value)) {
										var localDate = Zotero.Date.sqlToDate(value);
										value = Zotero.Date.dateToSQL(localDate).replace(' 00:00:00', '');
									}
									else {
										var d = Zotero.Date.strToDate(value);
										value = null;
										if (d.year && d.month != undefined && d.day) {
											d = new Date(d.year, d.month, d.day);
											value = Zotero.Date.dateToSQL(d).replace(' 00:00:00', '');
										}
									}
									break;
								
								default:
									// TODO: generalize to all date rows/fields
									// (Note: Using fieldStub rather than fieldName here
									// plays nice with multilingual rows for static
									// [non-creator] fields.)
									if (Zotero.ItemFields.isFieldOfBase(fieldStub, 'date')) {
										// Parse 'yesterday'/'today'/'tomorrow' and convert to dates,
										// since it doesn't make sense for those to be actual metadata values
										var lc = value.toLowerCase();
										if (lc == 'yesterday' || lc == Zotero.getString('date.yesterday')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() - 86400000)).substr(0, 10);
										}
										else if (lc == 'today' || lc == Zotero.getString('date.today')) {
											value = Zotero.Date.dateToSQL(new Date()).substr(0, 10);
										}
										else if (lc == 'tomorrow' || lc == Zotero.getString('date.tomorrow')) {
											value = Zotero.Date.dateToSQL(new Date(new Date().getTime() + 86400000)).substr(0, 10);
										}
									}
							}
						}
						if (Zotero.multiFieldNames[fieldStub]) {
							this._modifyField(fieldStub, value, this.saveOnEdit, fieldLanguage);
							var gottenField = this.item.multi.get(fieldStub, fieldLanguage);
						} else {
							this._modifyField(fieldName, value, this.saveOnEdit);
							var gottenField = this.item.getField(fieldName);
						}
						elem = this.createValueElement(
							gottenField,
							fieldName,
							tabindex
						);
					}
					
					var box = textbox.parentNode;
					box.replaceChild(elem,textbox);

					if(field === 'creator') {
						// Reset creator mode settings here so that flex attribute gets reset
						this.switchCreatorMode(row, (otherFields.fieldMode ? 1 : 0), true);

						if(Zotero.ItemTypes.getName(this.item.itemTypeID) === "bookSection") {
							var creatorTypeLabels = document.getAnonymousNodes(this)[0].getElementsByClassName("creator-type-label");
							document.getElementById("zotero-author-guidance").show(creatorTypeLabels[creatorTypeLabels.length-1]);
						}
					}
					
					if (this._tabDirection) {
						if (!focusMode) {
							var focusMode = 'info';
							var focusBox = this._dynamicFields;
						}
						this._focusNextField(focusBox, this._lastTabIndex, this._tabDirection == -1);
					}
				}
				// Thrown errors don't seem to show up within XBL without explicit logging
				catch (e) {
					Zotero.debug(e);
					Components.utils.reportError(e);
					throw (e);
				}
//Zotero.debug("XXX hideEditor() [end]");
				]]>
				</body>
			</method>
			
			
			<method name="_rowIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
				 	return this.clickByRow &&
						(this.clickable ||
							this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			
			<method name="_fieldIsClickable">
				<parameter name="fieldName"/>
				<body>
				<![CDATA[
					return !this.clickByRow &&
						((this.clickable && !Zotero.Items.isPrimaryField(fieldName))
							|| this._clickableFields.indexOf(fieldName) != -1);
				]]>
				</body>
			</method>
			
			<method name="_modifyField">
				<parameter name="field"/>
				<parameter name="value"/>
				<parameter name="save"/>
				<parameter name="language"/>
				<body>
				<![CDATA[
					// In this method, note that the "language" parameter
					// and the 'language' field are different things.
					// The former is the language of the dependent
					// field to be saved.  The latter is the base
					// language of the item.

					// Once the language is set, never allow it to be
					// set to nil, since that would result in invalid
					// RDF for orphaned variants.
					//
					
					if (value || 
						!(
							(!language &&
							  Zotero.multiFieldNames[field] &&
							  this.item.multi._keys[Zotero.ItemFields.getID(field)]
							) ||
							(
								field === 'language'
							)
						)
					) {

						if (Zotero.multiFieldNames[field]) {
							// false is for loadIn toggle
							this.item.setField(field,value, false, language);
						} else {
							this.item.setField(field,value);
						}
						if (save) {
							this.item.save();
							this.refresh();
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="_getFieldValue">
				<parameter name="label"/>
				<body>
				<![CDATA[
					return label.firstChild
						? label.firstChild.nodeValue : label.value;
				]]>
				</body>
			</method>
			
			
			<method name="_setFieldValue">
				<parameter name="label"/>
				<parameter name="value"/>
				<body>
				<![CDATA[
					if (label.firstChild) {
						label.firstChild.nodeValue = value;
					}
					else {
						label.value = value;
					}
				]]>
				</body>
			</method>
			
			
			<!-- TODO: work with textboxes too -->
			<method name="textTransform">
				<parameter name="label"/>
				<parameter name="mode"/>
				<body>
				<![CDATA[
					var val = this._getFieldValue(label);
					switch (mode) {
						case 'title':
							var newVal = Zotero.Utilities.capitalizeTitle(val.toLowerCase(), true);
							break;
						case 'sentence':
							// capitalize the first letter, including after beginning punctuation
							// capitalize after :, ?, ! and remove space(s) before those analogous to capitalizeTitle function
							// also deal with initial punctuation here - open quotes and Spanish beginning quotation marks
							newVal = val.toLowerCase();					
							newVal = newVal.replace(/(([:\?!]\s*|^)([\'\"Â¡Â¿âââÂ«\s]+)?[^\s])/g, function (x) { 
								return x.replace(/\s+/m, " ").toUpperCase();});
							break;
						default:
							throw ("Invalid transform mode '" + mode + "' in zoteroitembox.textTransform()");
					}
					this._setFieldValue(label, newVal);
					var fieldName = label.getAttribute('fieldname');
					if (!fieldName) {
						fieldName = label.parentNode.getAttribute('fieldname');
					}
					this._modifyField(fieldName, newVal, this.saveOnEdit);

				]]>
				</body>
			</method>
			
			<method name="swapMultiFields">
				<parameter name="elem"/>
				<body>
				<![CDATA[
					var row = Zotero.getAncestorByTagName(elem, 'row');
					var langTag = row.firstChild.getAttribute('servantLang');
					this.item.multi.swapFields(langTag);
				]]>
				</body>
			</method>
			
			<method name="getCreatorFields">
				<parameter name="row"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX getCreatorFields()");
					var typeID = row.getElementsByClassName('creator-type-label')[0].getAttribute('typeid');
					var label1 = row.getElementsByClassName('creator-name-box')[0].firstChild;
					var label2 = label1.parentNode.lastChild;
					var mynode = row.getElementsByClassName('creator-type-label')[0];
					var servantLang = mynode.getAttribute('servantLang');

					// If the second element of the fieldname string
					// is a number, this is not a multilingual entry
					var forceTop = false;
					var fieldstring = row.firstChild.getAttribute('fieldname');
					var fieldStringSuffix = fieldstring.split('-')[2];
					if (fieldStringSuffix === 'typeID') {
						forceTop = true;
					}

					var fields = {
						lastName: label1.firstChild ? label1.firstChild.nodeValue
							: label1.value,
						firstName: label2.firstChild ? label2.firstChild.nodeValue
							: label2.value,
						fieldMode: label1.getAttribute('fieldMode')
							? parseInt(label1.getAttribute('fieldMode')) : 0,
						shortName: '',
						birthYear: '',
						creatorTypeID: parseInt(typeID),
						servantLang: servantLang,
						forceTop: forceTop
					}
					
					// Ignore '(first)'
					if (fields.fieldMode == 1 || fields.firstName == this._defaultFirstName) {
						fields.firstName = '';
					}

					// Ignore '(last)' or '(name)'
					if (fields.lastName == this._defaultFullName
							|| fields.lastName == this._defaultLastName) {
						fields.lastName = '';
					}

					return fields;
				]]>
				</body>
			</method>
			
			<method name="modifyCreatorType">
				<parameter name="creatorTypeID"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX modifyCreatorType()");
					var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;
					var row = triggerNode.localName == 'hbox' ? triggerNode.parentNode : triggerNode.parentNode.parentNode;
					var fieldstring = row.firstChild.getAttribute('fieldname');
					var index = fieldstring.split('-')[1];
					var fieldStringSuffix = fieldstring.split('-')[2];
					var forceTop = false;
					if (fieldStringSuffix === 'typeID') {
						forceTop = true;
					}

					/* If a creator textbox is already open, we need to
					 * change its autocomplete parameters so that it
					 * completes on a creator with a different creator type
					 */
					var changedParams = {
						creatorTypeID: creatorTypeID
					};
					this._updateAutoCompleteParams(row, changedParams);
							
					var creator = this.item.getCreator(index);
					this.item.setCreator(index, creator.ref, creatorTypeID, creator.multi.main, forceTop);
					this.item.save();
					this.refresh();
				]]>
				</body>
			</method>


			<method name="modifyCreator">
				<parameter name="index"/>
				<parameter name="fields"/>
				<parameter name="changeGlobally"/>
				<parameter name="deferSave"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX modifyCreator() [start]");

// "creator" is an instance of Zotero.Creator, with lastName etc. directly accessible.

// "itemCreator" is a bundle of Zotero.Creator instances, on ref and multi, with
// creatorTypeID attached as well.
				try {

					var libraryID = this.item.libraryID;
					
					var oldItemCreator = this.item.getCreator(index);
					// Don't save empty creators
					if (!fields.firstName && !fields.lastName){
						if (!oldItemCreator || !oldItemCreator.ref.id) {
							return;
						}
						// Don't permit items to be deleted by deleting their content
						this.item.save();
						this.refresh();
						return;
					}
					Zotero.DB.beginTransaction();
					
// OOOOO: One more thing: if the field mode has changed,
// and the object already exists, populate the change
// across all creators registered in the object.

					var newLinkedCreators = [];

					var newCreator = new Zotero.Creator;
					newCreator.libraryID = libraryID;
					newCreator.setFields(fields);

					var creatorDataID = Zotero.Creators.getDataID(fields);
					if (creatorDataID) {
						newLinkedCreators = Zotero.Creators.getCreatorsWithData(creatorDataID, libraryID);
					}
					var oldCreator = false;
					if (oldItemCreator) {
						if (!fields.servantLang || fields.forceTop) {
							var creatorTarget = oldItemCreator.ref
						} else {
							// OOOOO: Possibly not the right place to catch
							// this, but I'm straining hard to follow the code.
							var creatorTarget = oldItemCreator.multi._key[fields.servantLang];
						}
						if (!creatorTarget.id) {
							//creatorTarget.save();
						}
						if (oldItemCreator.ref.equals(newCreator) && (oldItemCreator.ref.libraryID == newCreator.libraryID)) {
							if (oldItemCreator.creatorTypeID == fields.creatorTypeID && oldItemCreator.ref.id) {
								Zotero.debug("Creator " + oldItemCreator.ref.id + " hasn't changed or hasn't ever been fully saved");
							} else {
								// Just change creatorTypeID
								this.item.setCreator(index, creatorTarget, fields.creatorTypeID, fields.servantLang, fields.forceTop);
								// Honor defer save if this item creator is not yet registered
								// in the database, otherwise turn it off
								// (one of two checks in this function)
								if (this.item.hasCreatorAt(index)) {
									deferSave = false;
								}
								if (this.saveOnEdit && !deferSave) {
									this.item.save();
									this.refresh();
								}
							}
							Zotero.DB.commitTransaction();
							return;
						}
						oldCreator = creatorTarget;
					}
					var creator;
					var creatorID;
					if (oldCreator) {
if (oldCreator.id) {
						var numLinkedItems = oldCreator.countLinkedItems();
} else {
 var numLinkedItems = 0;
}
						// Creator is linked only to the current item
						if (numLinkedItems == 1) {
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								creator = Zotero.Creators.get(creatorID);
							} else {
								oldCreator.setFields(fields);
								creator = oldCreator;
							}
						} else if (!changeGlobally) {
							// Creator is linked to multiple items with changeGlobally off
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								creator = Zotero.Creators.get(creatorID);
							} else {
								creator = newCreator;
								//creator.save();
							}
						} else {
							// Creator is linked to multiple items with changeGlobally on
							throw ('changeGlobally unimplemented');
							if (newLinkedCreators.length) {
								// Use the first creator found with this data
								// TODO: support choosing among options
								creatorID = newLinkedCreators[0];
								
								// TODO: switch all linked items to this creator

								// TODO: multilingual support
							} else {
								creatorID = newCreator.save();
									
								// TODO: switch all linked items to new creatorID

								// TODO: multilingual support
							}
						}
					} else {
						// No existing creator
						if (newLinkedCreators.length) {
							creatorID = newLinkedCreators[0];
							creator = Zotero.Creators.get(creatorID);
						} else {
							creator = newCreator;
						}
					}
					// The latter condition is just a fixit: not sure of the exact
					// flow of logic on this.
					if (this.item.hasCreatorAt(index) 
						|| (this.item._creators.length === 0 
						&& (fields.lastName || fields.firstName))) {
						deferSave = false;
					}
					this.item.setCreator(index, creator, fields.creatorTypeID, fields.servantLang, fields.forceTop);
					if (this.saveOnEdit && !deferSave) {
						try {
							this.item.save();
							this.refresh();
						} catch (e) {
							// DEBUG: Errors aren't being logged in Fx3.1b4pre without this
							Zotero.debug("XXX item.save() oops: " + e);
							Components.utils.reportError(e);
							throw (e);
						}
					}
					Zotero.DB.commitTransaction();
				} catch (e) {
					Zotero.debug("XXX modifyCreator() oops: " + e);
					Components.utils.reportError(e);
					throw (e);
				}
//Zotero.debug("XXX modifyCreator() [end]");
				]]>
				</body>
			</method>

			<method name="swapNames">
				<body>
				<![CDATA[
					var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;
					var myelem = triggerNode.localName == 'hbox' ? triggerNode : triggerNode.parentNode;
					var elem = myelem.parentNode.firstChild.lastChild;
					var creatorIndex = parseInt(elem.getAttribute('fieldname').split('-')[1]);
					var row = Zotero.getAncestorByTagName(elem, 'row');
					var fields = this.getCreatorFields(row);
					var lastName = fields.lastName;
					var firstName = fields.firstName;
					fields.lastName = firstName;
					fields.firstName = lastName;
					this.modifyCreator(creatorIndex, fields, false, true);
					this.item.save();
					this.refresh();
				]]>
				</body>
			</method>
			
			
			<method name="moveCreator">
				<parameter name="moveUp"/>
				<body>
				<![CDATA[
//Zotero.debug("XXX moveCreator()");
					var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;
					var typeBox = triggerNode.localName == 'hbox' ? triggerNode : triggerNode.parentNode;
					var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);

					if (index === 0 && moveUp) {
						Zotero.debug("Can't move creator 0 up");
						return;
					}
					if (index === (this.item.numCreators() - 1) && !moveUp) {
						Zotero.debug("Can't move up creator "+index+" down");
						return;
					}
					this.item._changedCreators = {};
					this.item._changedAltCreators = {};
					if (moveUp) {
						var creator = this.item.getCreator(index);
						var predecessor = this.item.getCreator(index - 1);

						this.item._creators[index] = predecessor;
						this.item._creators[index - 1] = creator;

						this.item._changedCreators[index] = true;
						this.item._changedAltCreators[index] = predecessor.multi._key;

						this.item._changedCreators[index - 1] = true;
						this.item._changedAltCreators[index - 1] = creator.multi._key;
					} else {
						var creator = this.item.getCreator(index);
						var successor = this.item.getCreator(index + 1);
						
						this.item._creators[index] = successor;
						this.item._creators[index + 1] = creator;

						this.item._changedCreators[index] = true;
						this.item._changedAltCreators[index] = successor.multi._key;
						
						this.item._changedCreators[index + 1] = true;
						this.item._changedAltCreators[index + 1] = creator.multi._key;
					}
					this.item._changedItemData = true;
					this.item.save();
					this.refresh();
				]]>
				</body>
			</method>
			
			
			<method name="_updateAutoCompleteParams">
				<parameter name="row"/>
				<parameter name="changedParams"/>
				<body>
				<![CDATA[
					var textboxes = row.getElementsByTagName('textbox');
					if (textboxes.length) {
						var t = textboxes[0];
						var params = JSON.parse(t.getAttribute('autocompletesearchparam'));
						for (var param in changedParams) {
							params[param] = changedParams[param];
						}
						t.setAttribute('autocompletesearchparam', JSON.stringify(params));
					}
				]]>
				</body>
			</method>
			
			<!--
			/*
			function modifyCreatorByID(index, creatorID, creatorTypeID) {
				throw ('Unimplemented');
				var oldCreator = _itemBeingEdited.getCreator(index);
				if (creator) {
					oldCreator = creator.ref;
					var oldCreatorID = oldCreator.creatorID;
				}
				
				Zotero.debug("Old creatorID is " + oldCreatorID);
				
				_itemBeingEdited.setCreator(index, firstName, lastName, typeID, fieldMode);
				_itemBeingEdited.save();
			}
			*/
			-->
			
			
			<method name="focusFirstField">
				<parameter name="mode"/>
				<body>
				<![CDATA[
					switch (mode) {
						case 'info':
							this._focusNextField(this._dynamicFields, 0, false);
							break;
					}
				]]>
				</body>
			</method>
			
			
			<!-- 
				Advance the field focus forward or backward
				
				Note: We're basically replicating the built-in tabindex functionality,
				which doesn't work well with the weird label/textbox stuff we're doing.
				(The textbox being tabbed away from is deleted before the blur()
				completes, so it doesn't know where it's supposed to go next.)
			-->
			<method name="_focusNextField">
				<parameter name="box"/>
				<parameter name="tabindex"/>
				<parameter name="back"/>
				<body>
				<![CDATA[
					// Was seriously out of line with official Zotero, replaced verbatim
					// from official source, 15 March 2013.
					tabindex = parseInt(tabindex);
					
					if (back)
					{
						switch (tabindex)
						{
							case 1:
								//Zotero.debug('At beginning');
								document.getElementById('item-type-menu').focus();
								return false;
							
							case this._tabIndexMinCreators:
								var nextIndex = 1; // Title field
								break;
							
							case this._tabIndexMinFields:
								// No creators
								if (this._tabIndexMaxCreators == 0) {
									var nextIndex = 1; // Title field
								}
								else {
									var nextIndex = this._tabIndexMaxCreators;
								}
								break;
							
							default:
								var nextIndex = tabindex - 1;
						}
					}
					else
					{
						switch (tabindex)
						{
							case 1:
								var nextIndex = this._tabIndexMinCreators;
								break;
							
							case this._tabIndexMaxCreators:
								var nextIndex = this._tabIndexMinFields;
								break;
							
							case this._tabIndexMaxFields:
								//Zotero.debug('At end');
								return false;
							
							default:
								var nextIndex = tabindex + 1;
						}
					}
					
					Zotero.debug('Looking for tabindex ' + nextIndex, 4);
					
					var next = box.getElementsByAttribute('ztabindex', nextIndex);
					if (!next[0])
					{
						//Zotero.debug("Next field not found");
						return this._focusNextField(box, nextIndex, back);
					}
					
					next[0].click();
					
					// DEBUG: next[0] is always equal to the target element,
					// but for some reason it's necessary to scroll to the next
					// element when moving forward for the target element to
					// be fully in view
					if (!back && next[0].parentNode.nextSibling) {
						var visElem = next[0].parentNode.nextSibling;
					}
					else {
						var visElem = next[0];
					}
					this.ensureElementIsVisible(visElem);
					
					return true;
				]]>
				</body>
			</method>
			
			
			<method name="blurOpenField">
				<body>
				<![CDATA[
					var textboxes = document.getAnonymousNodes(this)[0].getElementsByTagName('textbox');
					if (textboxes && textboxes.length) {
						textboxes[0].inputField.blur();
					}
				]]>
				</body>
			</method>
			
			
			<!--
				Available handlers:
				
				  - 'itemtypechange'
				
				Note: 'this' in the function will be bound to the item box.
			-->
			<method name="addHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						this.eventHandlers[eventName] = [];
					}
					this.eventHandlers[eventName].push(func);
				]]>
				</body>
			</method>
			
			<method name="removeHandler">
				<parameter name="eventName"/>
				<parameter name="func"/>
				<body>
				<![CDATA[
					if (!this.eventHandlers[eventName]) {
						return;
					}
					var pos = this.eventHandlers[eventName].indexOf(func);
					if (pos != -1) {
						this.eventHandlers[eventName].splice(pos, 1);
					}
				]]>
				</body>
			</method>
			
			
			<method name="_id">
				<parameter name="id"/>
				<body>
				<![CDATA[
					return document.getAnonymousNodes(this)[0].getElementsByAttribute('id', id)[0];
				]]>
				</body>
			</method>

			<method name="setJurisdictionKey">
			  <parameter name="key"/>
			  <parameter name="node"/>
			  <body>
				<![CDATA[
					var jurisdictionDefaultNode = document.getElementById('jurisdiction-default');
					if (key && jurisdictionDefaultNode) {
						if (key && key == Zotero.Prefs.get("import.jurisdictionDefault")) {
							jurisdictionDefaultNode.setAttribute("checked",true);
						} else {
							jurisdictionDefaultNode.setAttribute("checked",false);
						}
					}
					this.item.setField("jurisdiction",key);
					node.setAttribute("style","");
					this.item.save();
				]]>
			  </body>
			</method>

		</implementation>
		
		<content>
			<scrollbox id="item-box" flex="1" orient="vertical"
				 	xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
				<popupset>
				  <menupopup id="multi-spawn-popup" 
							 position="after_start"
							 onpopupshowing="var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;return document.getBindingParent(this).refreshLanguages(triggerNode);">
					<label id="zotero-lang-add" 
						   style="font-weight:bold;" 
						   value="&zotero.items.menu.addTag;"/>
					<label id="zotero-lang-switch" 
						   style="font-weight:bold;" 
						   value="&zotero.items.menu.changeTag;" 
						   hidden="true"/>
					<vbox id="multi-spawn-menu"
						  minheight="50" maxheight="200" 
						  width="120" style="overflow:auto;">
					</vbox>
				  </menupopup>
				  <menupopup id="creator-type-menu" position="after_start"
						onpopupshowing="var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;var typeBox = triggerNode.localName == 'hbox' ? triggerNode : triggerNode.parentNode;
								var haslang = document.getBindingParent(this).refreshLanguages(typeBox);
								document.getElementById('zotero-creator-lang-menu').setAttribute('hidden', !haslang);
								var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);
								
								var item = document.getBindingParent(this).item;
								var exists = item.hasCreatorAt(index);
								var numCreators = item.numCreators();
								var moreCreators = numCreators > index + 1;

								var hideMoveSep = false;
								var hideMoveUp = false;
								var hideMoveDown = false;
								if (2 > item.numCreators) {
									hideMoveSep = true;
									hideMoveUp = true;
									hideMoveDown = true;
								} else {
									hideMoveDown = !moreCreators;
									hideMoveUp = (index == 0);
								}

								document.getElementById('zotero-creator-move-sep').setAttribute('hidden', hideMoveSep);
								document.getElementById('zotero-creator-move-up').setAttribute('hidden', hideMoveUp);
								document.getElementById('zotero-creator-move-down').setAttribute('hidden', hideMoveDown);"
						oncommand="
							if (event.explicitOriginalTarget.className == 'zotero-creator-move') {
								var up = event.explicitOriginalTarget.id == 'zotero-creator-move-up';
								document.getBindingParent(this).moveCreator(up);
								return;
							}
							
							var creatorTypeID = event.explicitOriginalTarget.getAttribute('typeid');
							document.getBindingParent(this).modifyCreatorType(creatorTypeID);">

						<menuseparator id="zotero-creator-move-sep"/>
						<menuitem id="zotero-creator-move-up" 
								  class="zotero-creator-move"
								  label="&zotero.items.menu.moveUp;"/>
						<menuitem id="zotero-creator-move-down" 
								  class="zotero-creator-move"
								  label="&zotero.items.menu.moveDown;"/>
						<menuseparator id="zotero-creator-lang-sep"/>
						<menu id="zotero-creator-lang-menu"
							position="start_after"
							onmouseover="document.getBindingParent(this)._multiSpawnPopup.openPopup(this,'start_after', null, null, true);"
							label="&zotero.items.menu.changeTag;"/>

					</menupopup>
					<menupopup id="zotero-field-transform-menu">
						<menu label="&zotero.item.textTransform;">
						  <menupopup>
								<menuitem label="&zotero.item.textTransform.titlecase;" class="menuitem-non-iconic"
									oncommand="var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;document.getBindingParent(this).textTransform(triggerNode, 'title')"/>
								<menuitem label="&zotero.item.textTransform.sentencecase;" class="menuitem-non-iconic"
									oncommand="var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;document.getBindingParent(this).textTransform(triggerNode, 'sentence')"/>
						  </menupopup>
						</menu>
					</menupopup>
					<menupopup id="creator-transform-menu"
						onpopupshowing="var triggerNode = document.triggerNode ? document.triggerNode : document.popupNode;var myBox = triggerNode.localName == 'hbox' ? triggerNode : triggerNode.parentNode;
										var typeBox = myBox.parentNode.firstChild.lastChild;
										var index = parseInt(typeBox.getAttribute('fieldname').split('-')[1]);								
										var item = document.getBindingParent(this).item;
										var exists = item.hasCreatorAt(index);
										if (exists) {
											var fieldMode = item.getCreator(index).ref.fieldMode;
										}
										var hideTransforms = !exists || !!fieldMode;
										if (hideTransforms) {
											return false;
										} else {
											return true;
										};">
						<menu label="&zotero.item.creatorTransform;">
							<menupopup>
							  <menuitem label="&zotero.item.creatorTransform.nameSwap;"
										class="menuitem-non-iconic creator-transform-swap-names"
										oncommand="document.getBindingParent(this).swapNames();"/>
							</menupopup>
						</menu>
					</menupopup>
					<zoteroguidancepanel id="zotero-author-guidance" about="authorMenu" position="after_end" x="-25"/>
				</popupset>
				<grid flex="1">
					<columns>
						<column/>
						<column flex="1"/>
					</columns>
					<rows id="dynamic-fields" flex="1">
						<row class="zotero-item-first-row">
							<label value="&zotero.items.itemType;: ..."/>
							<menulist class="zotero-clicky" id="item-type-menu" oncommand="document.getBindingParent(this).changeTypeTo(this.value, this)" flex="1"
								onfocus="document.getBindingParent(this).ensureElementIsVisible(this)"
								onkeypress="if (event.keyCode == event.DOM_VK_TAB) { document.getBindingParent(this).itemTypeMenuTab(event); }">
								<menupopup/>
							</menulist>
						</row>
					</rows>
				</grid>
			</scrollbox>
		</content>
	</binding>
</bindings>
